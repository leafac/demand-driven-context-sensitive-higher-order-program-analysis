@phdthesis{k-cfa,
  title={Control-flow analysis of higher-order languages},
  author={Shivers, Olin},
  year={1991},
  school={PhD thesis, Carnegie Mellon University}
}

@inproceedings{m-cfa,
 author = {Might, Matthew and Smaragdakis, Yannis and Van Horn, David},
 title = {Resolving and Exploiting the K-CFA Paradox: Illuminating Functional vs. Object-Oriented Program Analysis},
 year = {2010},
 isbn = {9781450300193},
 publisher = {Association for Computing Machinery},
 address = {New York, NY, USA},
 url = {https://doi.org/10.1145/1806596.1806631},
 doi = {10.1145/1806596.1806631},
 booktitle = {Proceedings of the 31st ACM SIGPLAN Conference on Programming Language Design and Implementation},
 pages = {305–315},
 numpages = {11},
 keywords = {functional, static analysis, object-oriented, k-cfa, pointer analysis, m-cfa, control-flow analysis},
 location = {Toronto, Ontario, Canada},
 series = {PLDI ’10}
}

@misc{stack-overflow-developer-survey,
  author = "Stack Overflow",
  title = "Developer Survey Results 2019",
  howpublished = "\url{https://insights.stackoverflow.com/survey/2019}",
  note = "Accessed 2020-01-14"
}

@misc{jet-brains-developer-survey,
  author = "JetBrains",
  title = "The State of Developer Ecosystem 2019",
  howpublished = "\url{https://www.jetbrains.com/lp/devecosystem-2019/}",
  note = "Accessed 2020-01-14"
}

@misc{arrow-function-expressions,
  author = "Mozilla",
  title = "Arrow function expressions",
  howpublished = "\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions}",
  note = "Accessed 2020-01-16"
}

@misc{destructuring-assignment,
  author = "Mozilla",
  title = "Destructuring assignment",
  howpublished = "\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment}",
  note = "Accessed 2020-01-27"
}

@misc{spread-syntax,
  author = "Mozilla",
  title = "Spread syntax",
  howpublished = "\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax}",
  note = "Accessed 2020-02-03"
}

@book{understanding-computation,
  author    =  "Tom Stuart", 
  title     = "Understanding Computation: From Simple Machines to Impossible Programs",
  publisher = "O'Reilly Media",
  year      = 2013,
  edition   = 1,
  isbn      = {1449329276}
}

@misc{bnf,
  author = "Matthew Might",
  title = "The language of languages",
  howpublished = "\url{http://matt.might.net/articles/grammars-bnf-ebnf/}",
  note = "Accessed 2020-01-17"
}

@book{dragon-book,
 author = {Aho, Alfred V. and Lam, Monica S. and Sethi, Ravi and Ullman, Jeffrey D.},
 title = {Compilers: Principles, Techniques, and Tools (2nd Edition)},
 year = {2006},
 isbn = {0321486811},
 publisher = {Addison-Wesley Longman Publishing Co., Inc.},
 address = {USA}
}

@misc{typescript,
  title = "TypeScript Homepage",
  howpublished = "\url{https://www.typescriptlang.org}",
  note = "Accessed 2020-01-17"
}

@InProceedings{understanding-typescript,
author="Bierman, Gavin
and Abadi, Mart{\'i}n
and Torgersen, Mads",
editor="Jones, Richard",
title="Understanding TypeScript",
booktitle="ECOOP 2014 -- Object-Oriented Programming",
year="2014",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="257--281",
abstract="TypeScript is an extension of JavaScript intended to enable easier development of large-scale JavaScript applications. While every JavaScript program is a TypeScript program, TypeScript offers a module system, classes, interfaces, and a rich gradual type system. The intention is that TypeScript provides a smooth transition for JavaScript programmers---well-established JavaScript programming idioms are supported without any major rewriting or annotations. One interesting consequence is that the TypeScript type system is not statically sound by design. The goal of this paper is to capture the essence of TypeScript by giving a precise definition of this type system on a core set of constructs of the language. Our main contribution, beyond the familiar advantages of a robust, mathematical formalization, is a refactoring into a safe inner fragment and an additional layer of unsafe rules.",
isbn="978-3-662-44202-9"
}

@misc{typescript-deep-dive,
  author = "Basarat Ali Syed",
  title = "TypeScript Deep Dive",
  howpublished = "\url{https://basarat.gitbook.io/typescript/}",
  note = "Accessed 2020-01-17"
}

@misc{estree,
  title = "The ESTree Spec",
  howpublished = "\url{https://github.com/estree/estree}",
  note = "Accessed 2020-01-21"
}

@misc{estree-types,
  title = "TypeScript Types for the ESTree Spec",
  howpublished = "\url{https://github.com/DefinitelyTyped/DefinitelyTyped/blob/1911a1fbbe30af03f0f38a915c4bf0620d251fc6/types/estree/index.d.ts}",
  note = "Accessed 2020-01-27"
}

@misc{esprima,
  title = "Esprima",
  howpublished = "\url{https://esprima.org}",
  note = "Accessed 2020-01-21"
}

@misc{esprima-demonstration,
  title = "Esprima Interactive Online Demonstration",
  howpublished = "\url{https://esprima.org/demo/parse.html}",
  note = "Accessed 2020-01-21"
}

@article{expressive-power,
title = "On the expressive power of programming languages",
journal = "Science of Computer Programming",
volume = "17",
number = "1",
pages = "35 - 75",
year = "1991",
issn = "0167-6423",
doi = "https://doi.org/10.1016/0167-6423(91)90036-W",
url = "http://www.sciencedirect.com/science/article/pii/016764239190036W",
author = "Matthias Felleisen",
abstract = "The literature on programming languages contains an abundance of informal claims on the relative expressive power of programming languages, but there is no framework for formalizing such statements nor for deriving interesting consequences. As a first step in this direction, we develop a formal notion of expressiveness and investigate its properties. To validate the theory, we analyze some widely held beliefs about the expressive power of several extensions of functional languages. Based on these results, we believe that our system correctly captures many of the informal ideas on expressiveness, and that it constitutes a foundation for further research in this direction."
}

@inproceedings{definitional-interpreters,
author = {Reynolds, John C.},
title = {Definitional Interpreters for Higher-Order Programming Languages},
year = {1972},
isbn = {9781450374927},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800194.805852},
doi = {10.1145/800194.805852},
booktitle = {Proceedings of the ACM Annual Conference - Volume 2},
pages = {717–740},
numpages = {24},
keywords = {Language definition, LISP, PAL, Programming language, Higher-order function, SECD machine, Closure, Lambda calculus, Reference, J-operator, Applicative language, GEDANKEN, Order of application, Interpreter, Continuation},
location = {Boston, Massachusetts, USA},
series = {ACM ’72}
}

@inproceedings{operational-semantics,
  title={Natural semantics},
  author={Kahn, Gilles},
  booktitle={Annual symposium on theoretical aspects of computer science},
  pages={22--39},
  year={1987},
  organization={Springer}
}

@article{call-by-name-call-by-value-and-the-lambda-calculus,
title = "Call-by-name, call-by-value and the λ-calculus",
journal = "Theoretical Computer Science",
volume = "1",
number = "2",
pages = "125 - 159",
year = "1975",
issn = "0304-3975",
doi = "https://doi.org/10.1016/0304-3975(75)90017-1",
url = "http://www.sciencedirect.com/science/article/pii/0304397575900171",
author = "G.D. Plotkin",
abstract = "This paper examines the old question of the relationship between ISWIM and the λ-calculus, using the distinction between call-by-value and call-by-name. It is held that the relationship should be mediated by a standardisation theorem. Since this leads to difficulties, a new λ-calculus is introduced whose standardisation theorem gives a good correspondence with ISWIM as given by the SECD machine, but without the letrec feature. Next a call-by-name variant of ISWIM is introduced which is in an analogous correspondence withthe usual λ-calculus. The relation between call-by-value and call-by-name is then studied by giving simulations of each language by the other and interpretations of each calculus in the other. These are obtained as another application of the continuation technique. Some emphasis is placed throughout on the notion of operational equality (or contextual equality). If terms can be proved equal in a calculus they are operationally equal in the corresponding language. Unfortunately, operational equality is not preserved by either of the simulations."
}
