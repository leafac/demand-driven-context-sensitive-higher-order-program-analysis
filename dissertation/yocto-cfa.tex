% !TEX program = lualatex
% !TEX options = -shell-escape -synctex=1 -interaction=nonstopmode -file-line-error "%DOC%"
% !BIB program = bibtex

\documentclass[12pt, oneside]{book}

\usepackage[a-1b]{pdfx}
\hypersetup{hidelinks, bookmarksnumbered}
\usepackage{tocbibind}

\usepackage[top = 1in, right = 1in, bottom = 1in, left = 1.5in]{geometry}
\usepackage[doublespacing]{setspace}

\pagestyle{plain}

\usepackage{fontspec, unicode-math}
\setmainfont{XCharter}
\setmonofont{FiraMono}[Scale = 0.9]
\setmathfont{TeX Gyre Pagella Math}

\usepackage{minted}
\usemintedstyle{vs}
\setminted{fontsize = \small, baselinestretch = 1}
\setmintedinline{fontsize = \normalsize}

\begin{document}

\frontmatter

\begin{center}
\begin{singlespace}
\vspace*{0.5in}

\textbf{\uppercase{Yocto-CFA}}

\vspace*{1in}

by

Leandro Facchinetti

\vspace*{1.5in}

A dissertation submitted to Johns Hopkins University\\in conformity with the requirements for the degree of Doctor of Philosophy

\vspace*{0.5in}

Baltimore, Maryland

August 2020
\end{singlespace}
\end{center}

\thispagestyle{empty}
\clearpage

\chapter{Abstract}

% TODO

\paragraph{Primary Reader and Advisor:}

Dr.~Scott Fraser Smith.

\paragraph{Readers:}

Dr.~Zachary Eli Palmer and Dr.~Matthew Daniel Green.

\chapter{Acknowledgements}

% TODO

\tableofcontents
\listoftables
\listoffigures

\mainmatter

% TODO: Introduction

\chapter{Developing an Analyzer}

% TODO: An overview of the rest of the section

\section{The Analyzed Language: Yocto-JavaScript}
\label{the-analyzed-language-yocto-javascript}

Our first decision when developing an analyzer is which language it should analyze. This is important because the analyzed language may affect the precision and the running time of the analyzer. For example, there is an analysis technique called $k$-CFA~\cite{k-cfa} that may be slower when applied to a language with higher-order functions than when applied to a language with objects (the algorithmic complexity of the former is exponential; of the latter, polynomial)~\cite{m-cfa}.

In this dissertation we are interested in analysis techniques for higher-order functions. Fortunately, we have plenty of options to choose from, because most languages support higher-order functions: JavaScript, Java, Python, Ruby, and so forth. From all these languages, we choose JavaScript because it is the most popular~\cite{stack-overflow-developer-survey, jet-brains-developer-survey}.

Unfortunately, JavaScript is a big language with many features besides higher-order functions, and an analyzer that tried to support all of them would end up being too complex. Instead, we define our own artificial little language based on the subset of JavaScript features that are related to higher-order functions. We call the resulting language \emph{Yocto-JavaScript} ($\mathrm{JavaScript} \times 10^{-24}$). By design, every Yocto-JavaScript program is also a JavaScript program, but the converse does not hold.

\subsection{Values in Yocto-JavaScript}

JavaScript has many kinds of values: strings (for example, \mintinline{js}{"Leandro"}), numbers (for example, \mintinline{js}{29}), arrays (for example, \mintinline{js}{["Leandro", 29]}), objects (for example, \mintinline{js}!{ name: "Leandro", age: 29 }!), and so forth. From all these kinds of values, Yocto-JavaScript only supports one: functions. Yocto-JavaScript functions are written as something called \emph{arrow function expressions}~\cite{arrow-function-expressions}; for example, \mintinline{js}{x => x} is a function of one parameter (before the \mintinline{js}{=>}) called \mintinline{js}{x}, and a body (after the \mintinline{js}{=>}) which consists of just a reference to the variable \mintinline{js}{x}. Yocto-JavaScript functions return the result of computing their body, so our example function simply returns whatever argument it was passed. (This example function is called the \emph{identity} function.)

Yocto-JavaScript functions are limited to have one parameter.

Because an Yocto-JavaScript function is a value, it may be returned by another function, or it may be the argument of a call to another function. For example, in \mintinline{js}{x => (y => y)} the function \mintinline{js}{y => y} is the return value, and in \mintinline{js}{f(y => y)} it is the argument of the call to a hypothetical function \mintinline{js}{f}. (This ability that functions have of behaving as values is what characterizes them as \emph{higher-order}.)

\subsection{Operations in Yocto-JavaScript}

JavaScript has many operations: numbers may be added together (for example, \mintinline{js}{29 + 1}), objects may have their properties accessed (for example, \mintinline{js}!{ name: "Leandro", age: 29 }.name!), and so forth. From all these operations, Yocto-JavaScript only supports two: functions may be called and variables may be referenced. Function calls are written as \mintinline{js}{f(a)}, where \mintinline{js}{f} is the function being called and \mintinline{js}{a} is the argument being passed to it.

The following is an example of the two operations supported by Yocto-JavaScript: \mintinline{js}{(x => x)(y => y)}.

In this program there is a function being called, \mintinline{js}{x => x}, and an argument being passed to it, \mintinline{js}{y => y} (functions are the only kind of value in Yocto-JavaScript, so the argument must itself be a function). As discussed above the \mintinline{js}{x => x} function simply returns whatever argument it was passed, so the result of the program is \mintinline{js}{y => y}. In general, a call (for example, \mintinline{js}{f(a)}) may appear in the body of a function (for example, \mintinline{js}{f => f(a)}) and in part of another call, either in the position of the function being called (for example, \mintinline{js}{(f(a))(b)}) or in the position of the argument (for example, \mintinline{js}{g(f(a))}).

The example program above also includes variable references: the \mintinline{js}{x} and \mintinline{js}{y} to the right of the respective \mintinline{js}{=>}. The only rule of variable references is that they must refer to variables that are defined; for example, in \mintinline{js}{x => x} the variable reference to \mintinline{js}{x} on the right of the \mintinline{js}{=>} is valid because \mintinline{js}{x} is defined on the left of the \mintinline{js}{=>}, but in \mintinline{js}{x => y} the variable reference to \mintinline{js}{y} on the right of the \mintinline{js}{=>} is invalid because \mintinline{js}{y} is undefined. A variable is only defined within the body of the function that defines it; for example, in \mintinline{js}{(x => y)(y => y)} the second reference to \mintinline{js}{y} on the right of the second \mintinline{js}{=>} is valid, because it is within the function that defines \mintinline{js}{y}, but the first reference to \mintinline{js}{y} on the right of the first \mintinline{js}{=>} is invalid. A variable is defined deep within the body of the function that defines it; for example, in \mintinline{js}{y => (x => y)} the reference to \mintinline{js}{y} is valid because it occurs deep within the body of the function that defines \mintinline{js}{y}.

(There are many technical terms related to this idea of where variables are defined. We say that a variable is \emph{in scope} in the body of the function that defines it. Similarly, the region of the program in which the variable is defined is called \emph{the scope} of the variable. Variable references that are in scope are said to be \emph{closed}, and we say that the whole program is \emph{closed} if all the variable references in it are closed. Conversely, variable references that are not in scope are said to be \emph{open}, and a program with at least one open variable reference is \emph{open}.)

We use parentheses to resolve ambiguities on where function definitions start and end, and on which order operations are computed (the \emph{precedence} of the operations). For example, there are at least two ways in which hypothetical functions \mintinline{js}{f}, \mintinline{js}{g}, and \mintinline{js}{h} may call one another:

\begin{enumerate}
\item \mintinline{js}{(f(g))(h)}: In this case \mintinline{js}{f(g)} happens first, and the result is a function that is called with \mintinline{js}{h}.

\item \mintinline{js}{f(g(h))}: In this case \mintinline{js}{g(h)} happens first, and the result is a function that is passed as argument to \mintinline{js}{f}.
\end{enumerate}

\subsection{The Computational Power of Yocto-JavaScript}

Yocto-JavaScript has very few features, which makes it an inconvenient language for programming, but its simplicity makes it the ideal language for discussing the analysis of higher-order functions. Also, perhaps surprisingly, Yocto-JavaScript has the same computational power as JavaScript (and Java, Python, Ruby, and so forth), in the sense that any JavaScript program may be translated into an equivalent Yocto-JavaScript program.

To carry out this translation, we \emph{encode} the features used by the original JavaScript program in terms of features supported by Yocto-JavaScript. For example, consider a JavaScript function of two parameters: \mintinline{js}{(x, y) => x}. This function is not supported by Yocto-JavaScript, which only allows for functions of one parameter, but we may encode it as a function that receives the first parameter and returns another function that receives the second parameter: \mintinline{js}{x => (y => x)}. Similarly, we may encode a call with multiple arguments as a sequence of calls that passes one argument at a time; for example, we may encode \mintinline{js}{f(a, b)} as \mintinline{js}{(f(a))(b)}. (This technique is called \emph{currying}.)

With some effort, it is possible to encode \emph{all} JavaScript features in terms of Yocto-JavaScript features~\cite[ยง~6]{understanding-computation}.

(In technical terms, we say that Yocto-JavaScript is a representation of something called \emph{call-by-value $\lambda$-calculus}~\cite[ยง~6]{understanding-computation}), and we describe its computational power by saying that Yocto-JavaScript is \emph{Turing complete}~\cite[ยง~7]{understanding-computation}.)

\subsection{A Formal Grammar for Yocto-JavaScript}

The following is a grammar that formalizes the informal description of Yocto-JavaScript given above (in \emph{BackusโNaur Form}~(BNF)~\cite{bnf}~\cite[ยง~4.2]{dragon-book}):

\begin{center}
\begin{tabular}{rcll}
$e$ & ::= & $x\texttt{ => }e$ | $e\texttt{(}e\texttt{)}$ | $x$ & Expressions \\
$x$ & ::= & \emph{<A Valid JavaScript Identifier>} & Variables \\
\end{tabular}
\end{center}

An expression $e$ is a valid Yocto-JavaScript program if and only if it is closed.

\section{The Analyzer Language: TypeScript}
\label{the-analyzer-language-typescript}

After choosing Yocto-JavaScript as our analyzed language (see ยง~\ref{the-analyzed-language-yocto-javascript}), we must decide in which language to develop the analyzer itself. Despite our choice of analyzed language being based on JavaScript, we could develop the analyzer in another language (Java, Python, Ruby, and so forth), because the analyzer simply treats Yocto-JavaScript programs as data. Still, from all these options, JavaScript offers some advantages: it is the most popular~\cite{stack-overflow-developer-survey, jet-brains-developer-survey}, and it includes tools to manipulate JavaScript programs. But we want to be able to discuss the \emph{types} of data structures, functions, and so forth (see, for example, ยง~\ref{a-parser-and-data-structures-to-represent-yocto-javascript programs}), and JavaScript does not have a way to express them, so instead we choose to implement our analyzer in \emph{TypeScript}~\cite{typescript, typescript-deep-dive, understanding-typescript}, which is an extension of JavaScript with support for types.

\section{A Parser and Data Structures to Represent Yocto-JavaScript Programs}
\label{a-parser-and-data-structures-to-represent-yocto-javascript programs}

We write Yocto-JavaScript programs (see ยง~\ref{the-analyzed-language-yocto-javascript}) in TypeScript (see ยง~\ref{the-analyzer-language-typescript}) as strings, for example, \mintinline{ts}{"x => x"}. But our analyzer would be exceedingly complex if it tried to manipulate these strings directly, so as its first step our analyzer \emph{parses} the programs into more convenient data structures. (This is a process called \emph{parsing}, and the data structures are called the \emph{Abstract Syntax Tree}~(AST) of the program~\cite[ยง~4]{dragon-book}.)

The following are examples of an Yocto-JavaScript programs and the corresponding data structures that the analyzer uses to represent them:

\begin{minted}{ts}
x => x

{
  "type": "ArrowFunctionExpression",
  "params": [
    {
      "type": "Identifier",
      "name": "x"
    }
  ],
  "body": {
    "type": "Identifier",
    "name": "x"
  }
}

(x => x)(y => y)

{
  "type": "CallExpression",
  "callee": {
    "type": "ArrowFunctionExpression",
    "params": [
      {
        "type": "Identifier",
        "name": "x"
      }
    ],
    "body": {
      "type": "Identifier",
      "name": "x"
    }
  },
  "arguments": [
    {
      "type": "ArrowFunctionExpression",
      "params": [
        {
          "type": "Identifier",
          "name": "y"
        }
      ],
      "body": {
        "type": "Identifier",
        "name": "y"
      }
    }
  ]
}
\end{minted}

We choose to represent Yocto-JavaScript programs with the data structures in the example above because they follow a standard called ESTree~\cite{estree}. ESTree is also used by other tools in the JavaScript ecosystem, including a parser called Esprima~\cite{esprima}, which we reuse to implement our Yocto-JavaScript parser. To explore the parser further, refer to the Esprima interactive online demonstration~\cite{esprima-demonstration}, which shows the ESTree-compliant data structures produced by a program as it is being typed.

Our Yocto-JavaScript parser starts by calling Esprima. Then it checks whether the program is using only the JavaScript features that are supported by Yocto-JavaScript. Finally, it cleans the data structures generated by Esprima to include only the data that the analyzer needs. The details of this implementation are deferred to ยง~\ref{the-yocto-javascript-parser-in-detail}.

% TODO: Data structure definitions

\appendix

\chapter{The Yocto-JavaScript Parser in Detail}
\label{the-yocto-javascript-parser-in-detail}

% TODO: Explain

\begin{minted}[linenos]{ts}
export function parse(input: string): Expression {
  const program = parseScript(input);
  if (program.body.length !== 1)
    throw new Error("โProgramโ has a โbodyโ whose length isnโt exactly one.");
  if (program.body[0].type !== "ExpressionStatement")
    throw new Error(
      "โProgramโ has a โbodyโ that isnโt an โExpressionStatementโ."
    );
  return checkAndCleanup(program.body[0].expression, new Set<string>());

  function checkAndCleanup(
    node: ESTree.Node,
    definedVariables: Set<string>
  ): Expression {
    switch (node.type) {
      case "ArrowFunctionExpression":
        if (node.params.length !== 1)
          throw new Error(
            "โArrowFunctionExpressionโ doesnโt have exactly one โparamโ."
          );
        if (node.params[0].type !== "Identifier")
          throw new Error(
            "โArrowFunctionExpressionโ has a โparamโ that isnโt an โIdentifierโ."
          );
        return {
          type: node.type,
          params: [
            {
              type: node.params[0].type,
              name: node.params[0].name
            }
          ],
          body: checkAndCleanup(
            node.body,
            new Set([...definedVariables, node.params[0].name])
          )
        };
      case "CallExpression":
        if (node.arguments.length !== 1)
          throw new Error(
            "โCallExpressionโ doesnโt have exactly one โargumentโ."
          );
        return {
          type: node.type,
          callee: checkAndCleanup(node.callee, definedVariables),
          arguments: [checkAndCleanup(node.arguments[0], definedVariables)]
        };
      case "Identifier":
        if (!definedVariables.has(node.name))
          throw new Error(`Variable reference to โ${node.name}โ not in scope.`);
        return {
          type: node.type,
          name: node.name
        };
      default:
        throw new Error(`Invalid node type: โ${node.type}โ.`);
    }
  }
}
\end{minted}

\backmatter

\bibliographystyle{plain}
\bibliography{\jobname}

\chapter{Biographical Statement}

% TODO

\end{document}
