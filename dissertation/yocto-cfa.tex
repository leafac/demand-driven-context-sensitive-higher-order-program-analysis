% !TEX program = lualatex
% !TEX options = -shell-escape -synctex=1 -interaction=nonstopmode -file-line-error "%DOC%"
% !BIB program = bibtex

\documentclass[12pt, oneside]{book}

\usepackage[a-1b]{pdfx}
\hypersetup{hidelinks, bookmarksnumbered}
\usepackage{tocbibind}

\usepackage[top = 1in, right = 1in, bottom = 1in, left = 1.5in]{geometry}
\usepackage[doublespacing]{setspace}

\pagestyle{plain}

\usepackage{fontspec, unicode-math}
\setmainfont{XCharter}
\setmonofont{FiraMono}[Scale = 0.9]
\setmathfont{TeX Gyre Pagella Math}

\usepackage{minted}
\usemintedstyle{vs}
\setminted{fontsize = \small, baselinestretch = 1}
\setmintedinline{fontsize = \normalsize}

\begin{document}

\frontmatter

\begin{center}
\begin{singlespace}
\vspace*{0.5in}

\textbf{\uppercase{Yocto-CFA}}

\vspace*{1in}

by

Leandro Facchinetti

\vspace*{1.5in}

A dissertation submitted to Johns Hopkins University\\in conformity with the requirements for the degree of Doctor of Philosophy

\vspace*{0.5in}

Baltimore, Maryland

August 2020
\end{singlespace}
\end{center}

\thispagestyle{empty}
\clearpage

\chapter{Abstract}

% TODO

\paragraph{Primary Reader and Advisor:}

Dr.~Scott Fraser Smith.

\paragraph{Readers:}

Dr.~Zachary Eli Palmer and Dr.~Matthew Daniel Green.

\chapter{Acknowledgements}

% TODO

\tableofcontents
\listoftables
\listoffigures

\mainmatter

% TODO: Introduction
% TODO: Link to GitHub

\chapter{Developing an Analyzer}

% TODO: An overview of the rest of the section

\section{The Analyzed Language: Yocto-JavaScript}
\label{The Analyzed Language: Yocto-JavaScript}

Our first decision when developing an analyzer is which language it should analyze. This is important because the analyzed language influences how difficult it is to build the analyzer, and it may also affect the analyzer’s precision and running time. For example, there is an analysis technique called $k$-CFA~\cite{k-cfa} that may be slower when applied to a language with higher-order functions than when applied to a language with objects (the algorithmic complexity of the former is exponential; of the latter, polynomial)~\cite{m-cfa}.

In this dissertation we are interested in analysis techniques for higher-order functions. Fortunately, most languages support higher-order functions, so we have plenty of options: JavaScript, Java, Python, Ruby, and so forth. From all these languages, we choose JavaScript because it is the most popular~\cite{stack-overflow-developer-survey, jet-brains-developer-survey}.

Unfortunately, JavaScript is a big language with many features besides higher-order functions, and an analyzer that tried to support all of them would be too complex. We address this issue by defining our own artificial little language based on a subset of JavaScript features that are related to higher-order functions. We call the resulting language \emph{Yocto-JavaScript} ($\mathrm{JavaScript} \times 10^{-24}$). By design, every Yocto-JavaScript program is also a JavaScript program, but the converse does not hold.

(In technical terms, we say that Yocto-JavaScript is a representation of something called the \emph{call-by-value $\lambda$-calculus}~\cite[§~6]{understanding-computation}).)

\subsection{Values in Yocto-JavaScript}
\label{Values in Yocto-JavaScript}

JavaScript has many kinds of values: strings (for example, \mintinline{js}{"Leandro"}), numbers (for example, \mintinline{js}{29}), arrays (for example, \mintinline{js}{["Leandro", 29]}), objects (for example, \mintinline{js}!{ name: "Leandro", age: 29 }!), and so forth. From all these kinds of values, Yocto-JavaScript only supports one: functions.

An Yocto-JavaScript function is written as \verb!<parameter> => <body>!, for example, \mintinline{js}{x => x}, in which the \verb!<parameter>! is called \mintinline{js}{x} and the \verb!<body>! is simply a reference to the variable \mintinline{js}{x} (see §~\ref{Operations in Yocto-JavaScript} for more on variable references). Because an Yocto-JavaScript function is a value, it may be passed as an argument in a function call, or returned as the result of a function call (see §~\ref{Operations in Yocto-JavaScript} for more on function calls). (This notation for writing functions is something called \emph{arrow function expressions}~\cite{arrow-function-expressions}. The function given as example is called the \emph{identity} function. The ability of being treated as values is what characterizes these functions as \emph{higher-order}.)

An Yocto-JavaScript function must have exactly one parameter.

\subsection{Operations in Yocto-JavaScript}
\label{Operations in Yocto-JavaScript}

JavaScript has many operations: strings may have its characters accessed (for example, \mintinline{js}{"Leandro"[2]}), numbers may be added together (for example, \mintinline{js}{29 + 1}), and so forth. From all these operations, Yocto-JavaScript only supports two: functions may be called and variables may be referenced.

A function call is written as \verb!<function>(<argument>)!, for example, \mintinline{js}{f(a)}, in which the \verb!<function>! is a hypothetical function \mintinline{js}{f} and the \verb!<argument>! is a hypothetical argument \mintinline{js}{a}.

An Yocto-JavaScript function call must have exactly one argument (because an Yocto-JavaScript function must have exactly one parameter; see §~\ref{Values in Yocto-JavaScript}).

A variable reference is written as a bare identifier, for example, \mintinline{js}{x}.

The following is a complete Yocto-JavaScript program that exemplifies all the supported operations:

\begin{minted}{js}
(x => x)(y => y)
\end{minted}

At the top level, this program is a call in which the \verb!<function>! is \mintinline{js}{x => x} and the \verb!<argument>! is \mintinline{js}{y => y}. When called, an Yocto-JavaScript function returns the result of computing its \verb!<body>!, and the \verb!<body>! of \mintinline{js}{x => x} is simply a reference to the variable \mintinline{js}{x}, so \mintinline{js}{x => x} is a function that returns its argument unchanged, and the final result of the example above is \mintinline{js}{y => y}.

In general, all kinds of Yocto-JavaScript expressions (function definitions, function calls, and variable references) may appear in the \verb!<body>! of a function definition, or as the \verb!<function>! or \verb!<argument>! of a call.

We use parentheses to resolve ambiguities on where function definitions start and end, and in which order operations are computed (something called the \emph{precedence} of the operations). For example, there are at least two ways in which hypothetical functions \mintinline{js}{f}, \mintinline{js}{g}, and \mintinline{js}{h} may call one another: \mintinline{js}{(f(g))(h)}, in which case \mintinline{js}{f(g)} happens first, and the result is a function that is called with \mintinline{js}{h}; and \mintinline{js}{f(g(h))}, in which case \mintinline{js}{g(h)} happens first, and the result is passed as argument to \mintinline{js}{f}.

\subsection{The Computational Power of Yocto-JavaScript}

Yocto-JavaScript has very few features, which makes it the ideal language for discussing the analysis of higher-order functions, but is it \emph{too} simple? Is there something that we may compute in JavaScript (or Java, Python, Ruby, and so forth) that is impossible to compute in Yocto-JavaScript? Perhaps surprisingly, the answer is negative: all these languages are equivalent in the sense that, with some effort, any program in any one language may be translated into an equivalent program in any other language~\cite[§~6]{understanding-computation}. (We say that these languages are equivalent in \emph{computational power}: they are all \emph{Turing complete}~\cite[§~7]{understanding-computation}. For our goal of exploring analysis techniques, we are concerned only with computational power, but it is worth noting that from a programmer’s perspective the features that a language supports (its \emph{expressive power}~\cite{expressive-power}) is more important, because it indicates how convenient the language is to use. Yocto-JavaScript is remarkably inexpressive, and therefore inconvenient for programming.)

As an example of how to carry out the translation from a real-world language into Yocto-JavaScript, consider a JavaScript function of two parameters: \mintinline{js}{(x, y) => x}. This function is not supported by Yocto-JavaScript, which only supports functions of one parameter (see §~\ref{Values in Yocto-JavaScript}), but we may encode it as a function that receives the first parameter and returns another function that receives the second parameter: \mintinline{js}{x => (y => x)}. Similarly, we may encode a call with multiple arguments as a sequence of calls that passes one argument at a time; for example, we may encode \mintinline{js}{f(a, b)} as \mintinline{js}{(f(a))(b)}. (This technique is called \emph{currying}.)

\subsection{A Formal Grammar for Yocto-JavaScript}
\label{A Formal Grammar for Yocto-JavaScript}

The description of Yocto-JavaScript given so far is informal; the following is a grammar that formalizes it (using \emph{Backus–Naur Form}~(BNF)~\cite{bnf}~\cite[§~4.2]{dragon-book}):

\begin{center}
\begin{tabular}{rcll}
$e$ & ::= & $x\texttt{ => }e$ | $e\texttt{(}e\texttt{)}$ | $x$ & Expressions \\
$x$ & ::= & \emph{<A Valid JavaScript Identifier>} & Variables \\
\end{tabular}
\end{center}

\section{The Analyzer Language: TypeScript}
\label{The Analyzer Language: TypeScript}

After choosing our analyzed language (Yocto-JavaScript; see §~\ref{The Analyzed Language: Yocto-JavaScript}), we must decide in which language to develop the analyzer itself. Our analyzed language is based on JavaScript, but the analyzer simply treats an analyzed program as data, so it may be developed in any language (Java, Python, Ruby, and so forth). Yet, from all these options, JavaScript does offer some advantages: it is the most popular~\cite{stack-overflow-developer-survey, jet-brains-developer-survey}, and it includes convenient tools to manipulate JavaScript programs (and therefore Yocto-JavaScript programs as well). But JavaScript lacks a way to express the \emph{types} of data structures, functions, and so forth, which we will need (for example, see §~\ref{Data Structures to Represent Yocto-JavaScript Programs}), so we choose to implement our analyzer in a JavaScript extension with support for types called \emph{TypeScript}~\cite{typescript, typescript-deep-dive, understanding-typescript}.

\section{Step 0: Substitution-Based Interpreter}
\label{Step 0: Substitution-Based Interpreter}

Having chosen the analyzed language (Yocto-JavaScript; see §~\ref{The Analyzed Language: Yocto-JavaScript}) and the language in which to develop the analyzer itself (TypeScript; see §~\ref{The Analyzer Language: TypeScript}), we are ready to start the series of steps in the development of the analyzer. The first Step is an interpreter that simply executes Yocto-JavaScript programs and produces the same outputs that would be produced a regular JavaScript interpreter. This is a good starting point for two reasons: first, this interpreter is the basis upon which we will build the analyzer; and second, the outputs of this interpreter are the ground truth against which we will validate the outputs of the analyzer.

\subsection{Architecture}
\label{Architecture}

Our interpreter is defined as a function called \mintinline{ts}{evaluate()}, which receives as parameter an Yocto-JavaScript program represented as a string and returns the result of running it. (The \mintinline{ts}{evaluate()} function is named after a native JavaScript function called \mintinline{js}{eval()}, which is similar to \mintinline{ts}{evaluate()} but for JavaScript programs.)

The following are two examples of how we will be able to use \mintinline{ts}{evaluate()} by the end of this Step (the \mintinline{ts}{>} represents the console):

\begin{minted}{ts}
> evaluate("x => x")
"x => x"
> evaluate("(x => x)(y => y)")
"y => y"
\end{minted}

The implementation of \mintinline{ts}{evaluate()} is separated in three parts called \mintinline{ts}{load()}, \mintinline{ts}{run()}, and \mintinline{ts}{unload()}:

\begin{minted}{ts}
export function evaluate(input: string): string {
  return unload(run(load(input)));
}
\end{minted}

The \mintinline{ts}{load()} function prepares the \mintinline{ts}{input} for interpretation, for example, converting it from a string into more convenient data structures (see §~\ref{Data Structures to Represent Yocto-JavaScript Programs}). The \mintinline{ts}{run()} function is responsible for the interpretation itself. The \mintinline{ts}{unload()} function converts the outputs of \mintinline{ts}{run()} into a human-readable format. In later steps the implementation of \mintinline{ts}{load()}, \mintinline{ts}{run()}, and \mintinline{ts}{unload()} will change, but the architecture and therefore the implementation of \mintinline{ts}{evaluate()} will remain the same. In the following sections we address the implementation of \mintinline{ts}{run()} first, deferring \mintinline{ts}{load()} to §~\ref{Step 0: Loader} and \mintinline{ts}{unload()} to §~\ref{Step 0: Unloader}.

\subsection{Data Structures to Represent Yocto-JavaScript Programs}
\label{Data Structures to Represent Yocto-JavaScript Programs}

The \mintinline{ts}{evaluate()} function receives an Yocto-JavaScript program represented as a string (see §~\ref{Architecture}). While a string is convenient for humans to write and read, it would be inconvenient for \mintinline{ts}{run()} to manipulate directly, because \mintinline{ts}{run()} is concerned with the \emph{structure} of the program instead of its \emph{text}: from \mintinline{ts}{run()}’s perspective, it does not matter, for example, whether a function is written as \mintinline{js}{x => x} or as \mintinline{js}{x=>x} (note the difference in spacing). So before \mintinline{ts}{run()} starts interpreting the program, \mintinline{ts}{load()} transforms it from a string into more convenient data structures (see §~\ref{Step 0: Loader} for \mintinline{ts}{load()}’s implementation).

The following are two examples of Yocto-JavaScript programs followed by the data structures used to represent them:

\begin{minted}{ts}
x => x

{
  "type": "ArrowFunctionExpression",
  "params": [
    {
      "type": "Identifier",
      "name": "x"
    }
  ],
  "body": {
    "type": "Identifier",
    "name": "x"
  }
}

(x => x)(y => y)

{
  "type": "CallExpression",
  "callee": {
    "type": "ArrowFunctionExpression",
    "params": [
      {
        "type": "Identifier",
        "name": "x"
      }
    ],
    "body": {
      "type": "Identifier",
      "name": "x"
    }
  },
  "arguments": [
    {
      "type": "ArrowFunctionExpression",
      "params": [
        {
          "type": "Identifier",
          "name": "y"
        }
      ],
      "body": {
        "type": "Identifier",
        "name": "y"
      }
    }
  ]
}
\end{minted}

We choose to represent Yocto-JavaScript programs with the data structures above because they follow a specification called ESTree~\cite{estree}, and by adhering to this specification we may reuse tools from the JavaScript ecosystem (see §~\ref{Step 0: Loader} and §~\ref{Step 0: Unloader}).

In general, the data structures used to represent Yocto-JavaScript programs are of the following types (written as TypeScript types adapted from the ESTree types specification~\cite{estree-types} to include only the features supported by Yocto-JavaScript):

\begin{minted}{ts}
type Expression = ArrowFunctionExpression | CallExpression | Identifier;

interface ArrowFunctionExpression {
  type: "ArrowFunctionExpression";
  params: [Identifier];
  body: Expression;
}

interface CallExpression {
  type: "CallExpression";
  callee: Expression;
  arguments: [Expression];
}

interface Identifier {
  type: "Identifier";
  name: string;
}
\end{minted}

(The definitions above correspond to elements of the Yocto-JavaScript grammar (see §~\ref{A Formal Grammar for Yocto-JavaScript}); for example, \mintinline{ts}{Expression} corresponds to $e$.)

In later steps various aspects of the interpreter will change, including parts of \mintinline{ts}{load()}, \mintinline{ts}{run()}, and \mintinline{ts}{unload()}, but the data structures used to represent Yocto-JavaScript programs will remain the same.

\subsection{Runner Structure}
\label{Runner Structure}

As mentioned in §~\ref{Data Structures to Represent Yocto-JavaScript Programs}, the \mintinline{ts}{run()} function receives as parameter an Yocto-JavaScript program represented as an \mintinline{ts}{Expression}. The \mintinline{ts}{run()} function is then responsible for interpreting the program and producing a value. In Yocto-JavaScript, the only kind of value is a function (see §~\ref{Values in Yocto-JavaScript}) (we use \mintinline{ts}{throw} as a placeholder for code that has not be written yet to prevent the TypeScript compiler from signaling type errors):

\begin{minted}{ts}
type Value = ArrowFunctionExpression;

function run(expression: Expression): Value {
  throw new Error("NOT IMPLEMENTED YET");
}
\end{minted}

The first thing that \mintinline{ts}{run()} has to do is to determine which type of \mintinline{ts}{expression} it is given:

\begin{minted}[highlightlines = {2-9}]{ts}
function run(expression: Expression): Value {
  switch (expression.type) {
    case "ArrowFunctionExpression":
      throw new Error("NOT IMPLEMENTED YET");
    case "CallExpression":
      throw new Error("NOT IMPLEMENTED YET");
    case "Identifier":
      throw new Error("NOT IMPLEMENTED YET");
  }
}
\end{minted}

In the sections below we fill in these placeholders step by step by considering example programs of increasing complexity.

\subsection{An Expression That Already Is a Value}

\paragraph{Example program:}

\begin{minted}{js}
x => x
\end{minted}

\paragraph{Current output:}

\begin{minted}{js}
NOT IMPLEMENTED YET
\end{minted}

\paragraph{Desired output:}

\begin{minted}{js}
x => x
\end{minted}

\paragraph{}

The \mintinline{ts}{expression} given to \mintinline{ts}{evaluate()} is already a \mintinline{ts}{Value}, which may be returned unchanged:

\begin{minted}[highlightlines = {2}]{ts}
case "ArrowFunctionExpression":
  return expression;
\end{minted}

\subsection{A Call Involving Immediate Functions}
\label{A Call Involving Immediate Functions}

\paragraph{Example program:}

\begin{minted}{js}
(x => x)(y => y)
\end{minted}

\paragraph{Current output:}

\begin{minted}{js}
NOT IMPLEMENTED YET
\end{minted}

\paragraph{Desired output (see §~\ref{Operations in Yocto-JavaScript}):}

\begin{minted}{js}
y => y
\end{minted}

\paragraph{}

Interpreting function calls is the main task of our interpreter. There are several techniques to do this and in this step we use one of the simplest: when the interpreter encounters a function call, it substitutes variable references in the body of the function that was called with the argument that was provided. This is similar to how we reason about functions in mathematics; for example, given the function $f(x) = x + 1$, we calculate $f(29)$ by substituting the references to $x$ in $f$ with the argument $29$: $f(29) = 29 + 1$. (This technique is what characterizes the interpreter in this Step as \emph{substitution-based}.)

In the example we are considering both the function that is called (\mintinline{js}{x => x}) and the argument (\mintinline{js}{y => y}) are immediate functions, as opposed to operations such as other function calls or variable references:

\begin{minted}[highlightlines = {2-6}]{ts}
case "CallExpression":
  if (
    expression.callee.type !== "ArrowFunctionExpression" ||
    expression.arguments[0].type !== "ArrowFunctionExpression"
  )
    throw new Error("NOT IMPLEMENTED YET");
  throw new Error("NOT IMPLEMENTED YET");
\end{minted}

The function that is called simply returns the argument unchanged (see §~\ref{Operations in Yocto-JavaScript}):

\begin{minted}[highlightlines = {7-8}]{ts}
case "CallExpression":
  if (
    expression.callee.type !== "ArrowFunctionExpression" ||
    expression.arguments[0].type !== "ArrowFunctionExpression"
  )
    throw new Error("NOT IMPLEMENTED YET");
  const argument = expression.arguments[0];
  return argument;
\end{minted}

\subsection{Substitution in Function Definitions}
\label{Substitution in Function Definitions}

\paragraph{Example program:}

\begin{minted}{js}
(x => z => x)(y => y)
\end{minted}

\paragraph{Current output:}

\begin{minted}{js}
y => y
\end{minted}

\paragraph{Desired output:}

\begin{minted}{js}
z => y => y
\end{minted}

\paragraph{}

Our implementation in §~\ref{A Call Involving Immediate Functions} works in the example given there, but it is far from working in the general case: it does not even consider the body of the called function, always returning the argument unchanged, which explains the current output of the example program above. What the interpreter must do is traverse the body of the called function looking for relevant variable references and substitute them. We unpack the called function using something called \emph{destructuring assignment}~\cite{destructuring-assignment} and implement this traversal with an auxiliary function called \mintinline{ts}{substitute()}:

\begin{minted}[highlightlines = {7-10, 12-15}]{ts}
case "CallExpression":
  if (
    expression.callee.type !== "ArrowFunctionExpression" ||
    expression.arguments[0].type !== "ArrowFunctionExpression"
  )
    throw new Error("NOT IMPLEMENTED YET");
  const {
    params: [{ name: parameter }],
    body
  } = expression.callee;
  const argument = expression.arguments[0];
  return substitute(body);
  function substitute(expression: Expression): Value {
    throw new Error("NOT IMPLEMENTED YET");
  }
\end{minted}

Similar to \mintinline{ts}{run()} itself, \mintinline{ts}{substitute()} starts by determining which type of \mintinline{ts}{expression} was passed to it:

\begin{minted}[highlightlines = {2-9}]{ts}
function substitute(expression: Expression): Value {
  switch (expression.type) {
    case "ArrowFunctionExpression":
      throw new Error("NOT IMPLEMENTED YET");
    case "CallExpression":
      throw new Error("NOT IMPLEMENTED YET");
    case "Identifier":
      throw new Error("NOT IMPLEMENTED YET");
  }
}
\end{minted}

When \mintinline{ts}{substitute()} starts traversing the \mintinline{ts}{body}, the \mintinline{ts}{expression} is an \mintinline{ts}{ArrowFunctionExpression}, \mintinline{js}{z => x}, and we want substitution to proceed deeper, to find and substitute \mintinline{js}{x}, so we call \mintinline{ts}{substitute()} recursively (we use a feature called \emph{spread syntax}~\cite{spread-syntax} to build an \mintinline{ts}{expression} based on the existing one with a new \mintinline{ts}{body}):

\begin{minted}[highlightlines = {2-9}]{ts}
case "ArrowFunctionExpression":
  return {
    ...expression,
    body: substitute(expression.body)
  };
\end{minted}

After this recursive call, \mintinline{ts}{substitute()} reaches the case in which the \mintinline{ts}{expression} is a variable reference (an \mintinline{ts}{Identifier}): \mintinline{js}{x}. When this happens, \mintinline{ts}{substitute()} performs the substitution by returning the \mintinline{ts}{argument}:

\begin{minted}[highlightlines = {2}]{ts}
case "Identifier":
  return argument;
\end{minted}

\subsection{Name Mismatch}

\paragraph{Example program:}

\begin{minted}{js}
(x => z => z)(y => y)
\end{minted}

\paragraph{Current output:}

\begin{minted}{js}
z => y => y
\end{minted}

\paragraph{Desired output:}

\begin{minted}{js}
z => z
\end{minted}

\paragraph{}

The implementation in §~\ref{Substitution in Function Definitions} succeeds in traversing the body of the called function, but it is substituting \emph{all} variable references, regardless of whether they refer to the parameter of the called function, which explains why it is substituting the \mintinline{js}{z} in the body even though the parameter is \mintinline{js}{x}. To fix this, we simply check whether the variable reference matches the parameter, and if it does not we prevent substitution from happening by retuning the variable reference unchanged:

\begin{minted}[highlightlines = {2}]{ts}
case "Identifier":
  if (expression.name !== parameter) return expression;
  return expression;
\end{minted}

But this leads to a problem with the type of \mintinline{ts}{substitute()}: it is not guaranteed to return a \mintinline{ts}{Value}, as declared in §~\ref{Substitution in Function Definitions}, but may return any type of \mintinline{ts}{Expression}, for example, variable references. We fix this by changing \mintinline{ts}{substitute()}’s type:

\begin{minted}[highlightlines = {6-10}]{ts}
function run(expression: Expression): Value {
  switch (expression.type) {
    // ...
    case "CallExpression":
      // ...
      const substitutedBody = substitute(body);
      if (substitutedBody.type !== "ArrowFunctionExpression")
        throw new Error("NOT IMPLEMENTED YET");
      return substitutedBody;
      function substitute(expression: Expression): Expression {
        // ...
      }
    // ...
  }
}
\end{minted}

* * *

In the program above, there are two options for the variable reference \mintinline{ts}{x} on the right of the second \mintinline{ts}{=>}: it may refer to the first (outer) \mintinline{ts}{x} on the left of the first \mintinline{ts}{=>}, in which case the output of the program would be \mintinline{js}{x => y => y}; or it may refer to the second (inner) \mintinline{ts}{x} on the left of the second \mintinline{ts}{=>}, in which case the output of the program would be \mintinline{js}{x => x}.

Currently, our \mintinline{ts}{substitute()} function is implementing the first option, but this leads to a serious issue: we are not able to reason about \mintinline{ts}{x => x} independently; we must know where it appears and whether a variable called \mintinline{ts}{x} is already defined there. We avoid this issue by modifying \mintinline{ts}{substitute()} to implement the second option, which is also implemented by JavaScript and every other popular programming language. (In technical terms, we say that the first option defeats something called \emph{local reasoning} and that the second option exhibits a behavior called \emph{shadowing}, because the outer \mintinline{ts}{x} is \emph{shadowed} by the inner \mintinline{ts}{x}.)

% TODO: big-step

\subsection{Loader}
\label{Step 0: Loader}

% TODO: (This is a process called \emph{parsing}, and the data structures are called the \emph{Abstract Syntax Tree}~(AST) of the program~\cite[§~4]{dragon-book}.)

\subsection{Unloader}
\label{Step 0: Unloader}

% TODO

% TODO: § A listing of the whole implementation.
% TODO: § Inference rules for interpreter.

\appendix

\backmatter

\bibliographystyle{plain}
\bibliography{\jobname}

\chapter{Biographical Statement}

% TODO

\end{document}
