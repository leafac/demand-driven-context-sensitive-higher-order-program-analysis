% !TEX program = lualatex
% !TEX options = -shell-escape -synctex=1 -interaction=nonstopmode -file-line-error "%DOC%"
% !BIB program = bibtex

\documentclass[12pt, oneside]{book}

\usepackage[a-1b]{pdfx}
\hypersetup{hidelinks, bookmarksnumbered}
\usepackage{tocbibind}

\usepackage[top = 1in, right = 1in, bottom = 1in, left = 1.5in]{geometry}
\usepackage[doublespacing]{setspace}

\pagestyle{plain}

\usepackage{fontspec, unicode-math}
\setmainfont{XCharter}
\setmonofont{FiraMono}[Scale = 0.9]
\setmathfont{TeX Gyre Pagella Math}

\usepackage{minted}
\usemintedstyle{vs}
\setminted{fontsize = \small, baselinestretch = 1}
\setmintedinline{fontsize = \normalsize}

\begin{document}

\frontmatter

\begin{center}
\begin{singlespace}
\vspace*{0.5in}

\textbf{\uppercase{Yocto-CFA}}

\vspace*{1in}

by

Leandro Facchinetti

\vspace*{1.5in}

A dissertation submitted to Johns Hopkins University\\in conformity with the requirements for the degree of Doctor of Philosophy

\vspace*{0.5in}

Baltimore, Maryland

August 2020
\end{singlespace}
\end{center}

\thispagestyle{empty}
\clearpage

\chapter{Abstract}

% TODO

\paragraph{Primary Reader and Advisor:}

Dr.~Scott Fraser Smith.

\paragraph{Readers:}

Dr.~Zachary Eli Palmer and Dr.~Matthew Daniel Green.

\chapter{Acknowledgements}

% TODO

\tableofcontents
\listoftables
\listoffigures

\mainmatter

% TODO: Introduction

\chapter{Developing an Analyzer}

% TODO: An overview of the rest of the section

\section{The Analyzed Language: Yocto-JavaScript}

Our first decision when developing an analyzer is which language it should analyze. This is important because the analyzed language may affect the precision and the running time of the analyzer. For example, there is an analysis technique called \(k\)-CFA~\cite{k-cfa} that may be slower when applied to a language with higher-order functions than when applied to a language with objects (the algorithmic complexity of the former is exponential; of the latter, polynomial)~\cite{m-cfa}.

In this dissertation we are interested in analysis techniques for higher-order functions. Fortunately, we have plenty of options, because most popular languages support higher-order functions: JavaScript, Java, Python, Ruby, and so forth. From all these languages, we choose JavaScript because it is the most widely used programming language~\cite{stack-overflow-developer-survey, jet-brains-developer-survey} and because it is understood by most people, even those who do not use it regularly.

Unfortunately, JavaScript is a big language with many features besides higher-order functions, and if we tried to support all of them we would end up with an analyzer that is too complex. Instead, we define our own artificial little language based on a subset of the features found in JavaScript—namely the features related to higher-order functions—which we call \emph{Yocto-JavaScript} (\(\mathrm{JavaScript} \times 10^{-24}\)). By design, every Yocto-JavaScript program is also a valid JavaScript program, but the converse does not hold.

\paragraph{Values in Yocto-JavaScript.}

JavaScript has many kinds of values: strings (for example, \mintinline{js}{"Leandro"}), numbers (for example, \mintinline{js}{29}), arrays (for example, \mintinline{js}{["Leandro", 29]}), objects (for example, \mintinline{js}!{ name: "Leandro", age: 29 }!), and so forth. Yocto-JavaScript has only one kind of value: functions. Yocto-JavaScript functions are written as something called \emph{arrow function expressions}~\cite{arrow-function-expressions}; for example, \mintinline{js}{x => x} is a function of one parameter (before the \mintinline{js}{=>}) called \mintinline{js}{x}, and a body (after the \mintinline{js}{=>}) which consists of just a reference to the variable \mintinline{js}{x}. Yocto-JavaScript functions return the result of computing their body, so our example function simply returns whatever argument it was passed. Yocto-JavaScript functions are limited to have one parameter.

Because an Yocto-JavaScript function is a value, it may be the return value of another function, or it may be the argument in a call to another function. For example, the function \mintinline{js}{y => y} is the return value of the function \mintinline{js}{x => (y => y)} and it is the argument in the call to the function \mintinline{js}{x => x} in \mintinline{js}{(x => x)(y => y)}. This ability to behave as values is what characterize these functions as \emph{higher-order}.

\paragraph{Operations in Yocto-JavaScript.}

JavaScript has many operations: numbers may be added together (for example, \mintinline{js}{29 + 1}), objects may have their properties accessed (for example, \mintinline{js}!{ name: "Leandro", age: 29 }.name!), and so forth. Yocto-JavaScript has only two operations: functions may be called and variables may be referenced.

The following is an example of these operations:

\begin{minted}{js}
(x => x)(y => y)
\end{minted}

In this program there is a function being called, \mintinline{js}{x => x}, and the argument being passed to it is \mintinline{js}{y => y} (functions are the only kind of value in Yocto-JavaScript, so the argument must itself be a function). As discussed above the \mintinline{js}{x => x} function simply returns whatever argument it was passed, so the result of the program is \mintinline{js}{y => y}.

The program above also includes examples of variable references: the \mintinline{js}{x} and \mintinline{js}{y} to the right of the respective \mintinline{js}{=>}.

We use parentheses to delimit function definitions and to indicate the order in which operations occur. For example, suppose \mintinline{js}{f}, \mintinline{js}{g}, and \mintinline{js}{h} are functions. There are at least two ways in which these functions may call one another:

\begin{enumerate}
\item \mintinline{js}{(f(g))(h)}: In this case \mintinline{js}{f(g)} happens first, and the result is a function that is called with \mintinline{js}{h}.

\item \mintinline{js}{f(g(h))}: In this case \mintinline{js}{g(h)} happens first, and the result is a function that is passed as argument to \mintinline{js}{f}.
\end{enumerate}

\paragraph{The Computational Power of Yocto-JavaScript.}

Yocto-JavaScript has very few features, which makes it an inconvenient language for programming, but it is ideal for our purpose of discussing the analysis of higher-order functions. Also, perhaps surprisingly, Yocto-JavaScript has the same computational power as JavaScript (and Java, Python, Ruby, and so forth), in the sense that any JavaScript program may be translated into an equivalent Yocto-JavaScript program.

To carry out this translation, we \emph{encode} the features used by the original JavaScript program in terms of features offered by Yocto-JavaScript. For example, consider a JavaScript function of two parameters: \mintinline{js}{(x, y) => x}. This function is not supported by Yocto-JavaScript because Yocto-JavaScript only allows for functions of one parameter, but we may encode it as a function that receives the first parameter and returns another function that receives the second parameter: \mintinline{js}{x => (y => x)}. Similarly, we may encode a call with multiple arguments as a sequence of calls that passes one argument at a time; for example, we may encode \mintinline{js}{f(a, b)} as \mintinline{js}{(f(a))(b)}. (This technique is called \emph{currying}.)

With some effort, it is possible to encode any JavaScript feature in terms of Yocto-JavaScript features~\cite[§~6]{understanding-computation}.

In technical terms, we say that Yocto-JavaScript is a representation of something called \emph{call-by-value \(\lambda\)-calculus}~\cite[§~6]{understanding-computation}), and we describe its computational power by saying that Yocto-JavaScript is \emph{Turing complete}~\cite[§~7]{understanding-computation}).

% TODO: Grammar.

\appendix

% TODO

\backmatter

\bibliographystyle{plain}
\bibliography{\jobname}

\chapter{Biographical Statement}

% TODO

\end{document}
