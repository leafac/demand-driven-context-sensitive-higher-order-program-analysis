% !TEX program = lualatex
% !TEX options = -shell-escape -synctex=1 -interaction=nonstopmode -file-line-error "%DOC%"
% !BIB program = bibtex

\documentclass[12pt, oneside]{book}

\usepackage[a-1b]{pdfx}
\hypersetup{hidelinks, bookmarksnumbered}
\usepackage{tocbibind}

\usepackage[top = 1in, right = 1in, bottom = 1in, left = 1.5in]{geometry}
\usepackage[doublespacing]{setspace}

\pagestyle{plain}

\usepackage{fontspec, unicode-math}
\setmainfont{XCharter}
\setmonofont{FiraMono}[Scale = 0.9]
\setmathfont{TeX Gyre Pagella Math}

\usepackage{minted}
\usemintedstyle{vs}
\setminted{fontsize = \small, baselinestretch = 1}
\setmintedinline{fontsize = \normalsize}

\begin{document}

\frontmatter

\begin{center}
\begin{singlespace}
\vspace*{0.5in}

\textbf{\uppercase{Yocto-CFA}}

\vspace*{1in}

by

Leandro Facchinetti

\vspace*{1.5in}

A dissertation submitted to Johns Hopkins University\\in conformity with the requirements for the degree of Doctor of Philosophy

\vspace*{0.5in}

Baltimore, Maryland

August 2020
\end{singlespace}
\end{center}

\thispagestyle{empty}
\clearpage

\chapter{Abstract}

% TODO

\paragraph{Primary Reader and Advisor:}

Dr.~Scott Fraser Smith.

\paragraph{Readers:}

Dr.~Zachary Eli Palmer and Dr.~Matthew Daniel Green.

\chapter{Acknowledgements}

% TODO

\tableofcontents
\listoftables
\listoffigures

\mainmatter

% TODO: Introduction
% TODO: Link to GitHub

\chapter{Developing an Analyzer}

% TODO: An overview of the rest of the section

\section{The Analyzed Language: Yocto-JavaScript}
\label{The Analyzed Language: Yocto-JavaScript}

Our first decision when developing an analyzer is which language it should analyze. This is important because the analyzed language may affect the precision and the running time of the analyzer. For example, there is an analysis technique called $k$-CFA~\cite{k-cfa} that may be slower when applied to a language with higher-order functions than when applied to a language with objects (the algorithmic complexity of the former is exponential; of the latter, polynomial)~\cite{m-cfa}.

In this dissertation we are interested in analysis techniques for higher-order functions. Fortunately, we have plenty of options to choose from, because most languages support higher-order functions: JavaScript, Java, Python, Ruby, and so forth. From all these languages, we choose JavaScript because it is the most popular~\cite{stack-overflow-developer-survey, jet-brains-developer-survey}.

Unfortunately, JavaScript is a big language with many features besides higher-order functions, and an analyzer that tried to support all of them would end up being too complex. Instead, we define our own artificial little language based on the subset of JavaScript features that are related to higher-order functions. We call the resulting language \emph{Yocto-JavaScript} ($\mathrm{JavaScript} \times 10^{-24}$). By design, every Yocto-JavaScript program is also a JavaScript program, but the converse does not hold.

\subsection{Values in Yocto-JavaScript}
\label{Values in Yocto-JavaScript}

JavaScript has many kinds of values: strings (for example, \mintinline{js}{"Leandro"}), numbers (for example, \mintinline{js}{29}), arrays (for example, \mintinline{js}{["Leandro", 29]}), objects (for example, \mintinline{js}!{ name: "Leandro", age: 29 }!), and so forth. From all these kinds of values, Yocto-JavaScript only supports one: functions. Yocto-JavaScript functions are written as something called \emph{arrow function expressions}~\cite{arrow-function-expressions}; for example, \mintinline{js}{x => x} is a function of one parameter (before the \mintinline{js}{=>}) called \mintinline{js}{x}, and a body (after the \mintinline{js}{=>}) which consists of just a reference to the variable \mintinline{js}{x}. Yocto-JavaScript functions return the result of computing their body, so our example function simply returns whatever argument it was passed. (This example function is called the \emph{identity} function.)

Yocto-JavaScript functions are limited to have one parameter.

Because an Yocto-JavaScript function is a value, it may be returned by another function, or it may be the argument of a call to another function. For example, in \mintinline{js}{x => (y => y)} the function \mintinline{js}{y => y} is the return value, and in \mintinline{js}{f(y => y)} it is the argument of the call to a hypothetical function \mintinline{js}{f}. (This ability that functions have of behaving as values is what characterizes them as \emph{higher-order}.)

\subsection{Operations in Yocto-JavaScript}

JavaScript has many operations: numbers may be added together (for example, \mintinline{js}{29 + 1}), objects may have their properties accessed (for example, \mintinline{js}!{ name: "Leandro", age: 29 }.name!), and so forth. From all these operations, Yocto-JavaScript only supports two: functions may be called and variables may be referenced. Function calls are written as \mintinline{js}{f(a)}, where \mintinline{js}{f} is the function being called and \mintinline{js}{a} is the argument being passed to it.

The following is an example of the two operations supported by Yocto-JavaScript: \mintinline{js}{(x => x)(y => y)}.

In this program there is a function being called, \mintinline{js}{x => x}, and an argument being passed to it, \mintinline{js}{y => y} (functions are the only kind of value in Yocto-JavaScript, so the argument must itself be a function). As discussed above the \mintinline{js}{x => x} function simply returns whatever argument it was passed, so the result of the program is \mintinline{js}{y => y}. In general, a call (for example, \mintinline{js}{f(a)}) may appear in the body of a function (for example, \mintinline{js}{f => f(a)}) and in part of another call, either in the position of the function being called (for example, \mintinline{js}{(f(a))(b)}) or in the position of the argument (for example, \mintinline{js}{g(f(a))}).

The example program above also includes variable references: the \mintinline{js}{x} and \mintinline{js}{y} to the right of the respective \mintinline{js}{=>}. The only rule of variable references is that they must refer to variables that are defined; for example, in \mintinline{js}{x => x} the variable reference to \mintinline{js}{x} on the right of the \mintinline{js}{=>} is valid because \mintinline{js}{x} is defined on the left of the \mintinline{js}{=>}, but in \mintinline{js}{x => y} the variable reference to \mintinline{js}{y} on the right of the \mintinline{js}{=>} is invalid because \mintinline{js}{y} is undefined. A variable is only defined within the body of the function that defines it; for example, in \mintinline{js}{(x => y)(y => y)} the second reference to \mintinline{js}{y} on the right of the second \mintinline{js}{=>} is valid, because it is within the function that defines \mintinline{js}{y}, but the first reference to \mintinline{js}{y} on the right of the first \mintinline{js}{=>} is invalid. A variable is defined deep within the body of the function that defines it; for example, in \mintinline{js}{y => (x => y)} the reference to \mintinline{js}{y} is valid because it occurs deep within the body of the function that defines \mintinline{js}{y}.

(There are many technical terms related to this idea of where variables are defined. We say that a variable is \emph{in scope} in the body of the function that defines it. Similarly, the region of the program in which the variable is defined is called \emph{the scope} of the variable. Variable references that are in scope are said to be \emph{closed}, and we say that the whole program is \emph{closed} if all the variable references in it are closed. Conversely, variable references that are not in scope are said to be \emph{open}, and a program with at least one open variable reference is \emph{open}.)

We use parentheses to resolve ambiguities on where function definitions start and end, and on which order operations are computed (the \emph{precedence} of the operations). For example, there are at least two ways in which hypothetical functions \mintinline{js}{f}, \mintinline{js}{g}, and \mintinline{js}{h} may call one another:

\begin{enumerate}
\item \mintinline{js}{(f(g))(h)}: In this case \mintinline{js}{f(g)} happens first, and the result is a function that is called with \mintinline{js}{h}.

\item \mintinline{js}{f(g(h))}: In this case \mintinline{js}{g(h)} happens first, and the result is a function that is passed as argument to \mintinline{js}{f}.
\end{enumerate}

\subsection{The Computational Power of Yocto-JavaScript}

Yocto-JavaScript has very few features, which makes it an inconvenient language for programming, but its simplicity makes it the ideal language for discussing the analysis of higher-order functions. Also, perhaps surprisingly, Yocto-JavaScript has the same computational power as JavaScript (and Java, Python, Ruby, and so forth), in the sense that any JavaScript program may be translated into an equivalent Yocto-JavaScript program.

To carry out this translation, we \emph{encode} the features used by the original JavaScript program in terms of features supported by Yocto-JavaScript. For example, consider a JavaScript function of two parameters: \mintinline{js}{(x, y) => x}. This function is not supported by Yocto-JavaScript, which only allows for functions of one parameter, but we may encode it as a function that receives the first parameter and returns another function that receives the second parameter: \mintinline{js}{x => (y => x)}. Similarly, we may encode a call with multiple arguments as a sequence of calls that passes one argument at a time; for example, we may encode \mintinline{js}{f(a, b)} as \mintinline{js}{(f(a))(b)}. (This technique is called \emph{currying}.)

With some effort, it is possible to encode \emph{all} JavaScript features in terms of Yocto-JavaScript features (see ยง~\ref{Encoding JavaScript Features in Yocto-JavaScript}).

(In technical terms, we say that Yocto-JavaScript is a representation of something called \emph{call-by-value $\lambda$-calculus}~\cite[ยง~6]{understanding-computation}), and we describe its computational power by saying that Yocto-JavaScript is \emph{Turing complete}~\cite[ยง~7]{understanding-computation}.)

\subsection{A Formal Grammar for Yocto-JavaScript}
\label{A Formal Grammar for Yocto-JavaScript}

The following is a grammar that formalizes the informal description of Yocto-JavaScript given above (in \emph{BackusโNaur Form}~(BNF)~\cite{bnf}~\cite[ยง~4.2]{dragon-book}):

\begin{center}
\begin{tabular}{rcll}
$e$ & ::= & $x\texttt{ => }e$ | $e\texttt{(}e\texttt{)}$ | $x$ & Expressions \\
$x$ & ::= & \emph{<A Valid JavaScript Identifier>} & Variables \\
\end{tabular}
\end{center}

An expression $e$ is a valid Yocto-JavaScript program if and only if it is closed.

\section{The Analyzer Language: TypeScript}
\label{The Analyzer Language: TypeScript}

After choosing Yocto-JavaScript as our analyzed language (see ยง~\ref{The Analyzed Language: Yocto-JavaScript}), we must decide in which language to develop the analyzer itself. Despite our choice of analyzed language being based on JavaScript, we could develop the analyzer in another language (Java, Python, Ruby, and so forth), because the analyzer simply treats Yocto-JavaScript programs as data. Still, from all these options, JavaScript offers some advantages: it is the most popular~\cite{stack-overflow-developer-survey, jet-brains-developer-survey}, and it includes tools to manipulate JavaScript programs. But we want to be able to discuss the \emph{types} of data structures, functions, and so forth (see, for example, ยง~\ref{A Parser and Data Structures to Represent Yocto-JavaScript Programs}), and JavaScript does not have a way to express them, so instead we choose to implement our analyzer in \emph{TypeScript}~\cite{typescript, typescript-deep-dive, understanding-typescript}, which is an extension of JavaScript with support for types.

\section{A Parser and Data Structures to Represent Yocto-JavaScript Programs}
\label{A Parser and Data Structures to Represent Yocto-JavaScript Programs}

We write Yocto-JavaScript programs (see ยง~\ref{The Analyzed Language: Yocto-JavaScript}) in TypeScript (see ยง~\ref{The Analyzer Language: TypeScript}) as strings (for example, \mintinline{ts}{"x => x"}), but manipulating these strings directly would be exceedingly complex, so we convert them into more convenient data structures. (This is a process called \emph{parsing}, and the data structures are called the \emph{Abstract Syntax Tree}~(AST) of the program~\cite[ยง~4]{dragon-book}.)

The following are two examples of Yocto-JavaScript programs and their corresponding data structures:

\begin{minted}{ts}
x => x

{
  "type": "ArrowFunctionExpression",
  "params": [
    {
      "type": "Identifier",
      "name": "x"
    }
  ],
  "body": {
    "type": "Identifier",
    "name": "x"
  }
}

(x => x)(y => y)

{
  "type": "CallExpression",
  "callee": {
    "type": "ArrowFunctionExpression",
    "params": [
      {
        "type": "Identifier",
        "name": "x"
      }
    ],
    "body": {
      "type": "Identifier",
      "name": "x"
    }
  },
  "arguments": [
    {
      "type": "ArrowFunctionExpression",
      "params": [
        {
          "type": "Identifier",
          "name": "y"
        }
      ],
      "body": {
        "type": "Identifier",
        "name": "y"
      }
    }
  ]
}
\end{minted}

We choose to represent Yocto-JavaScript programs with the data structures above because they follow a specification called ESTree~\cite{estree}. ESTree is also used by other tools in the JavaScript ecosystem, and by following the specification we may reuse them. In particular, we may reuse a parser for JavaScript called Esprima~\cite{esprima}. To explore Esprima and ESTree, refer to the Esprima interactive online demonstration~\cite{esprima-demonstration}. The details of how the Yocto-JavaScript parser is implemented and how it uses Esprima are deferred to ยง~\ref{The Yocto-JavaScript Parser in Detail}.

The following are the definitions of data structures produced by the Yocto-JavaScript parser:

\begin{minted}{ts}
type Expression = ArrowFunctionExpression | CallExpression | Identifier;

interface ArrowFunctionExpression {
  type: "ArrowFunctionExpression";
  params: [Identifier];
  body: Expression;
}

interface CallExpression {
  type: "CallExpression";
  callee: Expression;
  arguments: [Expression];
}

interface Identifier {
  type: "Identifier";
  name: string;
}
\end{minted}

These definitions are written as TypeScript types adapted from the ESTree specification to include only the features supported by Yocto-JavaScript. The definitions correspond to elements of the Yocto-JavaScript grammar (see ยง~\ref{A Formal Grammar for Yocto-JavaScript}); for example, \mintinline{ts}{Expression} corresponds to $e$.

This concludes the preliminary work necessary to start building the series of interpreters that lead to our analyzer.

\section{Step 0: Substitution-Based Interpreter}

Our first step toward an analyzer is an interpreter that simply executes Yocto-JavaScript programs and produces the same outputs as a regular JavaScript interpreter. This is a good starting point because it is the ground truth against which we will validate the outputs of our analyzer.

There are several techniques to develop an interpreter, and in this step we use one of the simplest: when the interpreter encounters a function call, it substitutes the variable references in the body of the called function with the argument. (In technical terms, this is a \emph{substitution-based interpreter}.)

This technique is similar to how we reason about function application in mathematics. For example, given the function definition $f(x) = x + 1$, we calculate $f(29)$ by substituting the references to $x$ in $f$ with the argument $29$: $f(29) = 29 + 1$.

Our interpreter is defined as a function called \mintinline{ts}{evaluate()}. The only parameter to the \mintinline{ts}{evaluate()} function is the \mintinline{ts}{Expression} to interpret, which typically is the result of calling the parser (see ยง~\ref{A Parser and Data Structures to Represent Yocto-JavaScript Programs}). The output of the \mintinline{ts}{evaluate()} function is a \mintinline{ts}{Value}, and the only kind of \mintinline{ts}{Value} in Yocto-JavaScript is a function (\mintinline{ts}{ArrowFunctionExpression}) (see ยง~\ref{Values in Yocto-JavaScript} and ยง~\ref{A Parser and Data Structures to Represent Yocto-JavaScript Programs}):

\begin{minted}{ts}
type Value = ArrowFunctionExpression;

export function evaluate(expression: Expression): Value {
  throw "TODO";
}
\end{minted}

% TODO: Inference rules for interpreter.

\appendix

\chapter{Encoding JavaScript Features in Yocto-JavaScript}
\label{Encoding JavaScript Features in Yocto-JavaScript}

% TODO: \cite[ยง~6]{understanding-computation}

\chapter{The Yocto-JavaScript Parser in Detail}
\label{The Yocto-JavaScript Parser in Detail}

See ยง~\ref{A Parser and Data Structures to Represent Yocto-JavaScript Programs} for an introduction on the Yocto-JavaScript parser. This section describes its implementation.

Most of the parsing work is done by a library called Esprima~\cite{esprima}, which is a parser for JavaScript that produces data structures following the ESTree~\cite{estree} specification. Esprima is also responsible for detecting syntax errors; for example, it detects that the program \mintinline{js}{x =>} is missing the function body. The rest of the Yocto-JavaScript parser checks whether the parsed program uses only the JavaScript features that are supported by Yocto-JavaScript; for example, it disallows the function \mintinline{js}{(x, y) => x} because it has multiple parameters. The parser also checks that all variable references refer to variables that are defined; for example, it disallows the program \mintinline{js}{x => y} because \mintinline{js}{y} is undefined. Finally, the parser cleans the data structures generated by Esprima, removing information that the analyzer does not need, for example, the location information relating the data structures back to their corresponding segments in the original input string.

The following is the implementation of the Yocto-JavaScript parser:

\begin{minted}[linenos]{ts}
export function parse(input: string): Expression {
  const program = parseScript(input);
  if (program.body.length !== 1)
    throw new Error("โProgramโ has a โbodyโ whose length isnโt exactly one.");
  if (program.body[0].type !== "ExpressionStatement")
    throw new Error(
      "โProgramโ has a โbodyโ that isnโt an โExpressionStatementโ."
    );
  return checkAndClean(program.body[0].expression, new Set<string>());

  function checkAndClean(
    node: ESTree.Node,
    definedVariables: Set<string>
  ): Expression {
    switch (node.type) {
      case "ArrowFunctionExpression":
        if (node.params.length !== 1)
          throw new Error(
            "โArrowFunctionExpressionโ doesnโt have exactly one โparamโ."
          );
        if (node.params[0].type !== "Identifier")
          throw new Error(
            "โArrowFunctionExpressionโ has a โparamโ that isnโt an โIdentifierโ."
          );
        return {
          type: node.type,
          params: [
            {
              type: node.params[0].type,
              name: node.params[0].name
            }
          ],
          body: checkAndClean(
            node.body,
            new Set([...definedVariables, node.params[0].name])
          )
        };
      case "CallExpression":
        if (node.arguments.length !== 1)
          throw new Error(
            "โCallExpressionโ doesnโt have exactly one โargumentโ."
          );
        return {
          type: node.type,
          callee: checkAndClean(node.callee, definedVariables),
          arguments: [checkAndClean(node.arguments[0], definedVariables)]
        };
      case "Identifier":
        if (!definedVariables.has(node.name))
          throw new Error(`Variable reference to โ${node.name}โ not in scope.`);
        return {
          type: node.type,
          name: node.name
        };
      default:
        throw new Error(`Invalid node type: โ${node.type}โ.`);
    }
  }
}
\end{minted}

\begin{description}
\item [Line~1:]

The parser is defined as a function called \mintinline{ts}{parse()}, which receives the program to be parsed as a \mintinline{ts}{string} called \mintinline{ts}{input}, and produces an \mintinline{ts}{Expression} (see ยง~\ref{A Parser and Data Structures to Represent Yocto-JavaScript Programs} for the definition of \mintinline{ts}{Expression} and the other data structures generated by the Yocto-JavaScript parser).

\item [Line~2:]

Call the Esprima \mintinline{ts}{parseScript()} function which produces ESTree-compliant data structures for the program. This function throws an exception in case the \mintinline{ts}{input} has a syntax error; for example, \mintinline{js}{x =>}, which is missing the function body.

\item [Lines~3โ8:]

Check whether the top-level \mintinline{ts}{program} is using only features supported by Yocto-JavaScript.

\begin{description}
\item [Lines~3โ4:]

The \mintinline{ts}{program} must include only one \mintinline{ts}{Statement}; for example, \mintinline{js}{x => x; y => y} is disallowed.

\item [Lines~5โ8:]

The sole \mintinline{ts}{Statement} must be an \mintinline{ts}{ExpressionStatement}; for example, \mintinline{js}{x => x} is allowed because it is an \mintinline{ts}{ExpressionStatement}, but \mintinline{js}{const f = x => x} is disallowed because it is a \mintinline{ts}{VariableDeclaration}.
\end{description}

\item [Line~9:]

Extract the sole \mintinline{ts}{Expression} from within the \mintinline{ts}{program}, which is the only part that the analyzer needs, and call the auxiliary function \mintinline{ts}{checkAndClean()} (see below).

\item [Lines~11โ14:]

The \mintinline{ts}{checkAndClean()} auxiliary function traverses the data structures generated by Esprima to perform three tasks: check that the features used by the parsed program are supported by Yocto-JavaScript, check that all variable references are for variables which are defined, and remove information that the analyzer does not need. (This traversal is an example of something called \emph{syntax-directed translation}~\cite[ยง~2]{dragon-book}.)

The \mintinline{ts}{checkAndClean()} function receives two parameters: \mintinline{ts}{node}, which is a data structure generated by Esprima (so called because it forms a tree); and \mintinline{ts}{definedVariables}, which is a set of variables defined where \mintinline{ts}{node} appears to be used for checking variable references (see below).

\item [Lines~15, 16, 38, 48, 55, 33โ36, 45โ46:]

On a high level, the \mintinline{ts}{checkAndClean()} function works by detecting the type of \mintinline{ts}{Node} it is given (Lines~15, 16, 38, 48, 55), performing some checks (see below), and then calling itself recursively with the parts that constitute the \mintinline{ts}{node} (Lines~33โ36, 45โ46). The recursive calls guarantee that \mintinline{ts}{checkAndClean()} visits every part of the data structure.

\item [Lines~17โ24, 39โ42, 49โ50, 56:]

After determining the type of the given \mintinline{ts}{node}, the \mintinline{ts}{checkAndClean()} function checks whether it is limited to using the features supported by Yocto-JavaScript, throwing an exception otherwise.

\begin{description}
\item [Lines~17โ20:]

A function definition must include exactly one parameter; for example, \mintinline{js}{(x, y) => x} is disallowed.

\item [Lines~21โ24:]

The parameter in a function definition must be an \mintinline{ts}{Identifier}; for example, \mintinline{js}{([x, y]) => x} is disallowed because the parameter is an \mintinline{ts}{ArrayPattern}.

\item [Lines~39โ42:]

A function call must include exactly one argument; for example, \mintinline{js}{f => a => b => f(a, b)} is disallowed.

\item [Lines~49โ50:]

Variable references must refer to variables that are defined (see below).

\item [Lines~56:]

Any type of \mintinline{ts}{Node} that has not been listed is not supported by Yocto-JavaScript, for example, \mintinline{ts}{29}, which is a \mintinline{ts}{Literal}.
\end{description}

\item [Lines~13, 9, 35, 45โ46, 49:]

To check that all variable references refer to defined variables, the \mintinline{ts}{checkAndClean()} function maintains a set of \mintinline{ts}{definedVariables} (Line~13). This set starts empty (Line~9) and is augmented when encountering a function definition (Line~35). The set is then checked when encountering a variable reference (Line~49). Other types of \mintinline{ts}{Node} that are not related to either defining or referencing variables pass \mintinline{ts}{definedVariables} unchanged on the recursive calls to \mintinline{ts}{checkAndClean()}; in Yocto-JavaScript this only happens in one case, function calls (Lines~45โ46), but in languages with more features most types of \mintinline{ts}{Node} are in this category, for example, those produced by \mintinline{js}{+}, \mintinline{js}{-}, \mintinline{js}{if}, and so forth.

For an example of how \mintinline{ts}{checkAndClean()} detects a problem in a variable reference, consider \mintinline{js}{x => y}. The set \mintinline{ts}{definedVariables} starts empty and is augmented with \mintinline{js}{x} upon encountering the function definition, but an exception is thrown when visiting the function body because \mintinline{ts}{y} is not included in \mintinline{ts}{definedVariables}.

\item [Lines~25โ37, 43โ47, 51โ54:]

To clean the data structures produced by Esprima and remove information that is not required by the analyzer, we explicitly reconstruct the data structures (see ยง~\ref{A Parser and Data Structures to Represent Yocto-JavaScript Programs} for the definition of the data structures).
\end{description}

The following is an example of how to use the parser (the \mintinline{ts}{>} represents the console):

\begin{minted}{ts}
> parse("x => x")
{
  "type": "ArrowFunctionExpression",
  "params": [
    {
      "type": "Identifier",
      "name": "x"
    }
  ],
  "body": {
    "type": "Identifier",
    "name": "x"
  }
}
\end{minted}

\backmatter

\bibliographystyle{plain}
\bibliography{\jobname}

\chapter{Biographical Statement}

% TODO

\end{document}
