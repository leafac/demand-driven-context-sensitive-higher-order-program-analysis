% !TEX program = lualatex
% !TEX options = -shell-escape -synctex=1 -interaction=nonstopmode -file-line-error "%DOC%"
% !BIB program = bibtex

\documentclass[12pt, oneside]{book}

\usepackage[a-1b]{pdfx}
\hypersetup{hidelinks, bookmarksnumbered}
\usepackage{tocbibind}

\usepackage[top = 1in, right = 1in, bottom = 1in, left = 1.5in]{geometry}
\usepackage[doublespacing]{setspace}

\pagestyle{plain}

\usepackage{fontspec, unicode-math}
\setmainfont{XCharter}
\setmonofont{FiraMono}[Scale = 0.9]
\setmathfont{TeX Gyre Pagella Math}

\usepackage{minted}
\usemintedstyle{vs}
\setminted{fontsize = \footnotesize, baselinestretch = 1}
\setmintedinline{fontsize = \normalsize}

\begin{document}

\frontmatter

\begin{center}
\begin{singlespace}
\vspace*{0.5in}

\textbf{\uppercase{Yocto-CFA}}

\vspace*{1in}

by

Leandro Facchinetti

\vspace*{1.5in}

A dissertation submitted to Johns Hopkins University\\in conformity with the requirements for the degree of Doctor of Philosophy

\vspace*{0.5in}

Baltimore, Maryland

August 2020
\end{singlespace}
\end{center}

\thispagestyle{empty}
\clearpage

\chapter{Abstract}

% TODO

\paragraph{Primary Reader and Advisor:}

Dr.~Scott Fraser Smith.

\paragraph{Readers:}

Dr.~Zachary Eli Palmer and Dr.~Matthew Daniel Green.

\chapter{Acknowledgements}

% TODO

\tableofcontents
\listoftables
\listoffigures

\mainmatter

% TODO: Introduction

\chapter{Developing an Analyzer}

% TODO: An overview of the rest of the section

\section{The Analyzed Language: Yocto-JavaScript}

\paragraph{The Importance of Choosing the Analyzed Language.}

Our first decision when developing an analyzer is the language that it analyzes. This decision is important because the analyzed language determines how difficult it is to develop the analyzer—more features in the analyzed language require a more elaborate analyzer. Also, the analyzed language may affect the analyzer’s precision and running time; for example, consider an analysis technique called \(k\)-CFA~\cite{k-cfa}: an analyzer using \(k\)-CFA on a language with higher-order functions may be slower than another analyzer using the same technique on a language with objects (the algorithmic complexity of the former is exponential; the latter, polynomial)~\cite{m-cfa}.

Our options of analyzed language are:

\begin{enumerate}
  \item \textbf{An artificial little language of our own design.} This is the approach most commonly taken by papers. Its benefit is that the analyzed language can be tailored for the kinds of discussions the authors want to have in the paper, but this approach has many drawbacks: the language is unfamiliar to the readers; it becomes impossible to reuse existing infrastructure, for example, parsers, pretty-printers, and so forth; and the language may not reflect the features that programmers actually use.
  
  On top of that, perhaps the biggest issue with this approach has to do with \emph{evaluating} the analyzer. Often the only code in an artificial little language is written by the authors of the analyzer themselves. This code tends to be only small programs and it is difficult for the authors to ensure that they are not biased to put the analyzer in a good light. One common solution to this problem is to develop a compiler from an existing real-world language to the artificial little language, but this comes with its own problems: it is even more engineering effort; the compiler may introduce artifacts that affect the analyzer’s performance; and it becomes more difficult to make sense of the analyzer’s result in terms of the real-world language in which the test programs were written originally.
  
  Another issue with this approach is that it requires some effort to be put into language design, but this is not a significant disadvantage in relation to the other approaches below, because they require comparable effort to be put into choosing a real-world language and the appropriate subset of features to analyze.

  \item \textbf{A real-world language.}

  \item \textbf{A subset of the features from a real-world language.}
\end{enumerate}

We choose option 3.

\paragraph{A Real-World Language to Analyze: JavaScript.}

From all the real-world languages we could choose, JavaScript is the best option. First, because it fulfills the prerequisite: it includes higher-order functions. Second, because it is the most used programming language in the world~\cite{stack-overflow-developer-survey, jet-brains-developer-survey}

\appendix

% TODO

\backmatter

\bibliographystyle{plain}
\bibliography{\jobname}

\chapter{Biographical Statement}

% TODO

\end{document}
