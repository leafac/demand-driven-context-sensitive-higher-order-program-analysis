% !TEX program = lualatex
% !TEX options = -shell-escape -synctex=1 -interaction=nonstopmode -file-line-error "%DOC%"
% !BIB program = bibtex

\documentclass[12pt, oneside]{book}

\usepackage[a-1b]{pdfx}
\hypersetup{hidelinks, bookmarksnumbered}
\usepackage{tocbibind}

\usepackage[top = 1in, right = 1in, bottom = 1in, left = 1.5in]{geometry}
\usepackage[doublespacing]{setspace}

\pagestyle{plain}

\usepackage{fontspec, unicode-math}
\setmainfont{XCharter}
\setmonofont{FiraMono}[Scale = 0.9]
\setmathfont{TeX Gyre Pagella Math}

\usepackage{minted}
\usemintedstyle{vs}
\setminted{fontsize = \footnotesize, baselinestretch = 1}
\setmintedinline{fontsize = \normalsize}

\begin{document}

\frontmatter

\begin{center}
\begin{singlespace}
\vspace*{0.5in}

\textbf{\uppercase{Yocto-CFA}}

\vspace*{1in}

by

Leandro Facchinetti

\vspace*{1.5in}

A dissertation submitted to Johns Hopkins University\\in conformity with the requirements for the degree of Doctor of Philosophy

\vspace*{0.5in}

Baltimore, Maryland

August 2020
\end{singlespace}
\end{center}

\thispagestyle{empty}
\clearpage

\chapter{Abstract}

% TODO

\paragraph{Primary Reader and Advisor:}

Dr.~Scott Fraser Smith.

\paragraph{Readers:}

Dr.~Zachary Eli Palmer and Dr.~Matthew Daniel Green.

\chapter{Acknowledgements}

% TODO

\tableofcontents
\listoftables
\listoffigures

\mainmatter

% TODO: Introduction

\chapter{Developing an Analyzer}

% TODO: An overview of the rest of the section

\section{The Analyzed Language: Yocto-JavaScript}

\paragraph{The Importance of Choosing the Analyzed Language.}

Our first decision when developing an analyzer is the analyzed language. This decision is important because the analyzed language determines how difficult it is to develop the analyzer—more features in the analyzed language require a more complicated analyzer. Also, the analyzed language may affect the analyzer’s precision and running time. One of the most notable examples of these effects may be observed with an analysis technique called \(k\)-CFA~\cite{k-cfa}: an analyzer using \(k\)-CFA that works over a language with higher-order functions may be slower than another using the exact same technique over a language with objects (the algorithmic complexity of the former is exponential; the latter, polynomial)~\cite{m-cfa}.

Our goal in this chapter is to introduce the techniques necessary to analyze higher-order functions and we want to keep the analyzer as simple as possible. An ideal analyzed language would have higher-order order functions as its \emph{only} feature, but no real-world language is that simple, so we restrict our analyzer to work over only \emph{some features} of a real-world language. (Many papers take a different approach and design their own artificial little language, but this has several disadvantages. First, the language may be unfamiliar to the readers. Second, it prevents the reuse of existing infrastructure, for example, parsers, pretty-printers, and so forth. Third, it prevents the analyzer from being tested with real-world code written by programmers who have not been involved in the development of the analyzer. Fourth, the artificial language may not reflect the features that programmers actually use. Finally, this approach requires some work to be put into language design, but this is not a significant disadvantage because it is comparable to the work we must put into choosing which features from which real-world language to support.)

\paragraph{A Real-World Language to Analyze: JavaScript.}

From all the real-world languages we could choose, JavaScript is the best option. First, because it fulfills the prerequisite: it includes higher-order functions. Second, because it is the most used programming language in the world~\cite{stack-overflow-developer-survey, jet-brains-developer-survey}

\appendix

% TODO

\backmatter

\bibliographystyle{plain}
\bibliography{\jobname}

\chapter{Biographical Statement}

% TODO

\end{document}
