% !TEX program = lualatex
% !TEX options = -shell-escape -synctex=1 -interaction=nonstopmode -file-line-error "%DOC%"
% !BIB program = bibtex

\documentclass[12pt, oneside]{book}

\usepackage[a-1b]{pdfx}
\hypersetup{hidelinks, bookmarksnumbered}
\usepackage{tocbibind}

\usepackage[top = 1in, right = 1in, bottom = 1in, left = 1.5in]{geometry}
\usepackage[doublespacing]{setspace}

\pagestyle{plain}

\usepackage{fontspec, unicode-math}
\setmainfont{XCharter}
\setmonofont{FiraMono}[Scale = 0.9]
\setmathfont{TeX Gyre Pagella Math}

\usepackage{minted}
\usemintedstyle{vs}
\setminted{fontsize = \small, baselinestretch = 1}
\setmintedinline{fontsize = \normalsize}

\begin{document}

\frontmatter

\begin{center}
\begin{singlespace}
\vspace*{0.5in}

\textbf{\uppercase{Yocto-CFA}}

\vspace*{1in}

by

Leandro Facchinetti

\vspace*{1.5in}

A dissertation submitted to Johns Hopkins University\\in conformity with the requirements for the degree of Doctor of Philosophy

\vspace*{0.5in}

Baltimore, Maryland

August 2020
\end{singlespace}
\end{center}

\thispagestyle{empty}
\clearpage

\chapter{Abstract}

% TODO

\paragraph{Primary Reader and Advisor:}

Dr.~Scott Fraser Smith.

\paragraph{Readers:}

Dr.~Zachary Eli Palmer and Dr.~Matthew Daniel Green.

\chapter{Acknowledgements}

% TODO

\tableofcontents
\listoftables
\listoffigures

\mainmatter

% TODO: Introduction
% TODO: Link to GitHub

\chapter{Developing an Analyzer}

% TODO: An overview of the rest of the section

\section{The Analyzed Language: Yocto-JavaScript}
\label{The Analyzed Language: Yocto-JavaScript}

Our first decision when developing an analyzer is which language it should analyze. This is important because the analyzed language may affect the precision and the running time of the analyzer. For example, there is an analysis technique called $k$-CFA~\cite{k-cfa} that may be slower when applied to a language with higher-order functions than when applied to a language with objects (the algorithmic complexity of the former is exponential; of the latter, polynomial)~\cite{m-cfa}.

In this dissertation we are interested in analysis techniques for higher-order functions. Fortunately, we have plenty of languages to choose from, because most of them support higher-order functions: JavaScript, Java, Python, Ruby, and so forth. From all these languages, we choose JavaScript because it is the most popular~\cite{stack-overflow-developer-survey, jet-brains-developer-survey}.

Unfortunately, JavaScript is a big language with many features besides higher-order functions, and an analyzer that tried to support all of them would be too complex. We address this issue by defining our own artificial little language based on a subset of JavaScript features that are related to higher-order functions. We call the resulting language \emph{Yocto-JavaScript} ($\mathrm{JavaScript} \times 10^{-24}$). By design, every Yocto-JavaScript program is also a JavaScript program, but the converse does not hold.

\subsection{Values in Yocto-JavaScript}
\label{Values in Yocto-JavaScript}

JavaScript has many kinds of values: strings (for example, \mintinline{js}{"Leandro"}), numbers (for example, \mintinline{js}{29}), arrays (for example, \mintinline{js}{["Leandro", 29]}), objects (for example, \mintinline{js}!{ name: "Leandro", age: 29 }!), and so forth. From all these kinds of values, Yocto-JavaScript only supports one: functions.

A Yocto-JavaScript function is written as \verb!<parameter> => <body>!, for example, \mintinline{js}{x => x}, in which the \verb!<parameter>! is called \mintinline{js}{x} and the \verb!<body>! is simply a reference to the variable \mintinline{js}{x} (see §~\ref{Operations in Yocto-JavaScript} for more on variable references). (This way of writing functions is something called \emph{arrow function expressions}~\cite{arrow-function-expressions}, and the example function that was given is called the \emph{identity} function.)

An Yocto-JavaScript function must have exactly one parameter.

\subsection{Operations in Yocto-JavaScript}
\label{Operations in Yocto-JavaScript}

JavaScript has many operations: strings may have its characters accessed (for example, \mintinline{js}{"Leandro"[2]}), numbers may be added together (for example, \mintinline{js}{29 + 1}), and so forth. From all these operations, Yocto-JavaScript only supports two: functions may be called and variables may be referenced.

A function call is written as \verb!<function>(<argument>)!, for example, \mintinline{js}{f(a)}, in which the \verb!<function>! is a hypothetical function \mintinline{js}{f} and the \verb!<argument>! is a hypothetical argument \mintinline{js}{a}.

An Yocto-JavaScript function call must have exactly one argument (because an Yocto-JavaScript function must have exactly one parameter; see §~\ref{Values in Yocto-JavaScript}).

A variable reference is written as a bare identifier, for example, \mintinline{js}{x}.

The following is a complete Yocto-JavaScript program that exemplifies these two operations:

\begin{minted}{js}
(x => x)(y => y)
\end{minted}

At the top level, this program is a call in which the \mintinline{js}{<function>} is \mintinline{js}{x => x} and the \mintinline{js}{<argument>} is \mintinline{js}{y => y}.

Yocto-JavaScript functions return the result of computing their \mintinline{js}{<body>}, so when called our example function simply returns whatever argument it is passed (see §~\ref{Operations in Yocto-JavaScript} for more on function calls). 

In this program there is a function being called, \mintinline{js}{x => x}, and an argument being passed to it, \mintinline{js}{y => y} (functions are the only kind of value in Yocto-JavaScript (see §~\ref{Values in Yocto-JavaScript}), so the argument must be a function itself). As discussed in §~\ref{Values in Yocto-JavaScript}, the \mintinline{js}{x => x} function simply returns whatever argument it is passed, so the result of our example program is \mintinline{js}{y => y}. In general, a call (for example, \mintinline{js}{f(a)}) may appear in the body of a function (for example, \mintinline{js}{f => f(a)}) or as part of another call, either in the position of the function being called (for example, \mintinline{js}{(f(a))(b)}) or in the position of the argument (for example, \mintinline{js}{g(f(a))}).

SINGLE ARGUMENT

The example program above also includes variable references: the \mintinline{js}{x} and \mintinline{js}{y} to the right of their respective \mintinline{js}{=>}.

We use parentheses to resolve ambiguities on where function definitions start and end, and in which order operations are computed (the \emph{precedence} of the operations). For example, there are at least two ways in which hypothetical functions \mintinline{js}{f}, \mintinline{js}{g}, and \mintinline{js}{h} may call one another: \mintinline{js}{(f(g))(h)}, in which case \mintinline{js}{f(g)} happens first, and the result is a function that is called with \mintinline{js}{h}; and \mintinline{js}{f(g(h))}, in which case \mintinline{js}{g(h)} happens first, and the result is passed as argument to \mintinline{js}{f}.

Because an Yocto-JavaScript function is a value, it may be returned by another function, or it may be the argument of a call. For example, in \mintinline{js}{x => (y => y)} the function \mintinline{js}{y => y} is the return value, and in \mintinline{js}{f(y => y)} it is the argument of the call to a hypothetical function \mintinline{js}{f}. (This ability that functions have of behaving as values is what characterizes them as \emph{higher-order}.)

\subsection{The Computational Power of Yocto-JavaScript}

Yocto-JavaScript has very few features, which makes it an inconvenient language for programming, but its simplicity makes it the ideal language for discussing the analysis of higher-order functions. Also, perhaps surprisingly, Yocto-JavaScript has the same computational power as JavaScript (and Java, Python, Ruby, and so forth), in the sense that any JavaScript program may be translated into an equivalent Yocto-JavaScript program.

To carry out this translation, we would \emph{encode} the features used by the original JavaScript program in terms of features supported by Yocto-JavaScript. For example, consider a JavaScript function of two parameters: \mintinline{js}{(x, y) => x}. This function is not supported by Yocto-JavaScript, which only allows for functions of one parameter, but we may encode it as a function that receives the first parameter and returns another function that receives the second parameter: \mintinline{js}{x => (y => x)}. Similarly, we may encode a call with multiple arguments as a sequence of calls that passes one argument at a time; for example, we may encode \mintinline{js}{f(a, b)} as \mintinline{js}{(f(a))(b)}. (This technique is called \emph{currying}.)

With some effort, it is possible to encode \emph{all} JavaScript features in terms of Yocto-JavaScript features (see §~\ref{Encoding JavaScript Features in Yocto-JavaScript}).

(In technical terms, we say that Yocto-JavaScript is a representation of something called the \emph{call-by-value $\lambda$-calculus}~\cite[§~6]{understanding-computation}), and we describe its computational power by saying that Yocto-JavaScript is \emph{Turing complete}~\cite[§~7]{understanding-computation}.)

\subsection{A Formal Grammar for Yocto-JavaScript}
\label{A Formal Grammar for Yocto-JavaScript}

The description of Yocto-JavaScript given up to this point in §~\ref{The Analyzed Language: Yocto-JavaScript} is informal; the following is a grammar that formalizes it (in \emph{Backus–Naur Form}~(BNF)~\cite{bnf}~\cite[§~4.2]{dragon-book}):

\begin{center}
\begin{tabular}{rcll}
$e$ & ::= & $x\texttt{ => }e$ | $e\texttt{(}e\texttt{)}$ | $x$ & Expressions \\
$x$ & ::= & \emph{<A Valid JavaScript Identifier>} & Variables \\
\end{tabular}
\end{center}

An expression $e$ is a valid Yocto-JavaScript program if and only if it is closed.

\section{The Analyzer Language: TypeScript}
\label{The Analyzer Language: TypeScript}

After choosing Yocto-JavaScript as our analyzed language (see §~\ref{The Analyzed Language: Yocto-JavaScript}), we must decide in which language to develop the analyzer itself. Despite choosing an analyzed language based on JavaScript (see §~\ref{The Analyzed Language: Yocto-JavaScript}), we could develop the analyzer in another language (Java, Python, Ruby, and so forth), because the analyzer simply treats Yocto-JavaScript programs as data. From all these languages, JavaScript offers some advantages: it is the most popular~\cite{stack-overflow-developer-survey, jet-brains-developer-survey}, and it includes convenient tools to manipulate JavaScript programs. But JavaScript lacks a way to express the \emph{types} of data structures, functions, and so forth, which we need to do (see, for example, §~\ref{A Parser and Data Structures to Represent Yocto-JavaScript Programs}), so instead of JavaScript we choose to implement our analyzer in \emph{TypeScript}~\cite{typescript, typescript-deep-dive, understanding-typescript}, an extension of JavaScript with support for types.

\section{A Parser and Data Structures to Represent Yocto-JavaScript Programs}
\label{A Parser and Data Structures to Represent Yocto-JavaScript Programs}

We write Yocto-JavaScript programs (see §~\ref{The Analyzed Language: Yocto-JavaScript}) in TypeScript (see §~\ref{The Analyzer Language: TypeScript}) as strings (for example, \mintinline{ts}{"x => x"}), but manipulating these strings directly would be exceedingly complex, so we convert them into more convenient data structures. (This is a process called \emph{parsing}, and the data structures are called the \emph{Abstract Syntax Tree}~(AST) of the program~\cite[§~4]{dragon-book}.)

The Yocto-JavaScript parser is implemented as a function called \mintinline{ts}{parse()}. The details of how \mintinline{ts}{parse()} is implemented are deferred to §~\ref{The Yocto-JavaScript Parser in Detail}, but the following are two examples of how it is used and what data structures it outputs (the \mintinline{ts}{>} represents the console):

\begin{minted}{ts}
> parse("x => x")
{
  "type": "ArrowFunctionExpression",
  "params": [
    {
      "type": "Identifier",
      "name": "x"
    }
  ],
  "body": {
    "type": "Identifier",
    "name": "x"
  }
}
> parse("(x => x)(y => y)")
{
  "type": "CallExpression",
  "callee": {
    "type": "ArrowFunctionExpression",
    "params": [
      {
        "type": "Identifier",
        "name": "x"
      }
    ],
    "body": {
      "type": "Identifier",
      "name": "x"
    }
  },
  "arguments": [
    {
      "type": "ArrowFunctionExpression",
      "params": [
        {
          "type": "Identifier",
          "name": "y"
        }
      ],
      "body": {
        "type": "Identifier",
        "name": "y"
      }
    }
  ]
}
\end{minted}

We choose to represent Yocto-JavaScript programs with the data structures above because they follow a specification called ESTree~\cite{estree}. In general, \mintinline{ts}{parse()} may produce data structures of the following types (written as TypeScript types that are adapted from the ESTree types~\cite{estree-types} to include only the features supported by Yocto-JavaScript):

\begin{minted}{ts}
type Expression = ArrowFunctionExpression | CallExpression | Identifier;

interface ArrowFunctionExpression {
  type: "ArrowFunctionExpression";
  params: [Identifier];
  body: Expression;
}

interface CallExpression {
  type: "CallExpression";
  callee: Expression;
  arguments: [Expression];
}

interface Identifier {
  type: "Identifier";
  name: string;
}
\end{minted}

The definitions above correspond to elements of the Yocto-JavaScript grammar (see §~\ref{A Formal Grammar for Yocto-JavaScript}); for example, \mintinline{ts}{Expression} corresponds to $e$.

This concludes the preliminary work necessary to start the series of steps that lead to our analyzer.

\section{Step 0: Substitution-Based Interpreter}
\label{Step 0: Substitution-Based Interpreter}

Our first step toward an analyzer is an interpreter that simply executes Yocto-JavaScript programs and produces the same outputs as a regular JavaScript interpreter. This is a good starting point because the outputs of this interpreter are the ground truth against which we will validate the outputs of the analyzer we end up developing.

There are several techniques to develop an interpreter and in this step we use one of the simplest: when the interpreter encounters a function call, it substitutes variable references in the called function body with the argument. This is similar to how we reason about functions in mathematics; for example, given the function $f(x) = x + 1$, we calculate $f(29)$ by substituting the references to $x$ in $f$ with the argument $29$: $f(29) = 29 + 1$. (In technical terms, we are developing something called a \emph{substitution-based interpreter}.)

\subsection{The Skeleton}

Our interpreter is defined as a function called \mintinline{ts}{evaluate()}. The only parameter to \mintinline{ts}{evaluate()} is a \mintinline{ts}{string} representing a Yocto-JavaScript program. The output of \mintinline{ts}{evaluate()} is a \mintinline{ts}{Value} (recall from §~\ref{Operations in Yocto-JavaScript} that functions are the only kind of value in Yocto-JavaScript). The following are two examples of how to use \mintinline{ts}{evaluate()}:

\begin{minted}{ts}
> evaluate("x => x")
{
  "type": "ArrowFunctionExpression",
  "params": [
    {
      "type": "Identifier",
      "name": "x"
    }
  ],
  "body": {
    "type": "Identifier",
    "name": "x"
  }
}
> evaluate("(x => x)(y => y)")
{
  "type": "ArrowFunctionExpression",
  "params": [
    {
      "type": "Identifier",
      "name": "y"
    }
  ],
  "body": {
    "type": "Identifier",
    "name": "y"
  }
}
\end{minted}

We begin to implement \mintinline{ts}{evaluate()} by declaring the input and output types (we use \mintinline{ts}{throw} as a placeholder for code that has not been written yet to prevent the TypeScript compiler from signaling errors):

\begin{minted}{ts}
type Value = ArrowFunctionExpression;

export function evaluate(expression: Expression): Value {
  throw "TODO";
}
\end{minted}

The first thing that \mintinline{ts}{evaluate()} has to do is to determine which type of \mintinline{ts}{expression} it is given:

\begin{minted}{ts}
export function evaluate(expression: Expression): Value {
  switch (expression.type) {
    case "ArrowFunctionExpression":
      throw "TODO";
    case "CallExpression":
      throw "TODO";
    case "Identifier":
      throw "TODO";
  }
}
\end{minted}

In the sections below we fill in these placeholders step-by-step by considering example programs of increasing complexity.

\subsection{An Expression That Is Already a Value}

\begin{description}
\item [Example program:] ~

\begin{minted}{js}
x => x
\end{minted}

\item [Expected output:] ~

\begin{minted}{js}
x => x
\end{minted}
\end{description}

The \mintinline{ts}{expression} given to \mintinline{ts}{evaluate()} is already a \mintinline{ts}{Value}, which may be returned unchanged:

\begin{minted}{ts}
case "ArrowFunctionExpression":
  return expression;
\end{minted}

\subsection{A Call Involving Immediate Functions}

\begin{description}
\item [Example program:] ~

\begin{minted}{js}
(x => x)(y => y)
\end{minted}

\item [Expected output (see §~\ref{Operations in Yocto-JavaScript}):] ~

\begin{minted}{js}
y => y
\end{minted}
\end{description}

In this case the \mintinline{ts}{expression} given to \mintinline{ts}{evaluate()} is a \mintinline{ts}{CallExpression} in which both the \mintinline{ts}{callee} and the \mintinline{ts}{argument} are \mintinline{ts}{ArrowFunctionExpression}s. We use \emph{destructuring assignment}~\cite{destructuring-assignment} to unpack these data structures, which we will use in subsequent sections, but for the example program above it suffices to return the \mintinline{ts}{argument}:

\begin{minted}{ts}
case "CallExpression":
  if (
    expression.callee.type !== "ArrowFunctionExpression" ||
    expression.arguments[0].type !== "ArrowFunctionExpression"
  )
    throw "TODO";
  const {
    params: [{ name }],
    body
  } = expression.callee;
  const argument = expression.arguments[0];
  return argument;
\end{minted}

\subsection{A Call in Which Substitution Must Occur Within Another Function}

\begin{description}
\item [Example program:] ~

\begin{minted}{js}
(x => z => x)(y => y)
\end{minted}

\item [Expected output:] ~

\begin{minted}{js}
z => y => y
\end{minted}
\end{description}

As illustrated by the program above, substitution may occur deep within the called function body, so we define an auxiliary function called \mintinline{ts}{substitute()} which traverses the body looking for variable references and substituting them:

\begin{minted}[highlightlines = 12-18]{ts}
case "CallExpression":
  if (
    expression.callee.type !== "ArrowFunctionExpression" ||
    expression.arguments[0].type !== "ArrowFunctionExpression"
  )
    throw "TODO";
  const {
    params: [{ name }],
    body
  } = expression.callee;
  const argument = expression.arguments[0];
  const bodyAfterSubstitution = substitute(body);
  if (bodyAfterSubstitution.type !== "ArrowFunctionExpression")
    throw "TODO";
  return bodyAfterSubstitution;
  function substitute(expression: Expression): Expression {
    throw "TODO";
  }
\end{minted}

Similar to \mintinline{ts}{evaluate()} itself, \mintinline{ts}{substitute()} also starts by determining the type of \mintinline{ts}{expression}:

\begin{minted}{ts}
function substitute(expression: Expression): Expression {
  switch (expression.type) {
    case "ArrowFunctionExpression":
      throw "TODO";
    case "CallExpression":
      throw "TODO";
    case "Identifier":
      throw "TODO";
  }
}
\end{minted}

When \mintinline{ts}{substitute()} encounters an \mintinline{ts}{ArrowFunctionExpression}, it must continue the substitution in the body of that function; for example, in the program we are considering, when \mintinline{ts}{substitute()} encounters \mintinline{js}{z => x} it must continue the substitution in the function body: \mintinline{js}{x}. We achieve that with a recursive call to \mintinline{ts}{substitute()}:

\begin{minted}{ts}
case "ArrowFunctionExpression":
  return {
    ...expression,
    body: substitute(expression.body)
  };
\end{minted}

After this recursive call, \mintinline{ts}{substitute()} reaches the case in which the \mintinline{ts}{expression} is a variable reference (an \mintinline{ts}{Identifier}). When this happens, \mintinline{ts}{substitute()} performs the substitution by returning the \mintinline{ts}{argument}:

\begin{minted}{ts}
case "Identifier":
  return argument;
\end{minted}

\subsection{A Call in Which Substitution Must Stop Because of Shadowing}

\begin{description}
\item [Example program:] ~

\begin{minted}{js}
(x => x => x)(y => y)
\end{minted}

\item [Expected output:] ~

\begin{minted}{js}
x => x
\end{minted}
\end{description}

In the program above, there are two options for the variable reference \mintinline{ts}{x} on the right of the second \mintinline{ts}{=>}: it may refer to the first (outer) \mintinline{ts}{x} on the left of the first \mintinline{ts}{=>}, in which case the output of the program would be \mintinline{js}{x => y => y}; or it may refer to the second (inner) \mintinline{ts}{x} on the left of the second \mintinline{ts}{=>}, in which case the output of the program would be \mintinline{js}{x => x}.

Currently, our \mintinline{ts}{substitute()} function is implementing the first option, but this leads to a serious issue: we are not able to reason about \mintinline{ts}{x => x} independently; we must know where it appears and whether a variable called \mintinline{ts}{x} is already defined there. We avoid this issue by modifying \mintinline{ts}{substitute()} to implement the second option, which is also implemented by JavaScript and every other popular programming language. (In technical terms, we say that the first option defeats something called \emph{local reasoning} and that the second option exhibits a behavior called \emph{shadowing}, because the outer \mintinline{ts}{x} is \emph{shadowed} by the inner \mintinline{ts}{x}.)

% TODO: A listing of the whole implementation.
% TODO: Inference rules for interpreter.

\appendix

\chapter{Encoding JavaScript Features in Yocto-JavaScript}
\label{Encoding JavaScript Features in Yocto-JavaScript}

% TODO: \cite[§~6]{understanding-computation}

\chapter{The Yocto-JavaScript Parser in Detail}
\label{The Yocto-JavaScript Parser in Detail}

See §~\ref{A Parser and Data Structures to Represent Yocto-JavaScript Programs} for an introduction to the Yocto-JavaScript parser. This section describes its implementation in detail.

Most of the work of parsing Yocto-JavaScript programs is deferred to a JavaScript parser called Esprima~\cite{esprima}, which produces data structures following the ESTree specification~\cite{estree} (refer to the Esprima interactive online demonstration~\cite{esprima-demonstration} to explore Esprima and ESTree further). Esprima is also responsible for detecting syntax errors; for example, it detects that the program \mintinline{js}{x =>} is missing the function body. The rest of the Yocto-JavaScript parser checks whether the parsed program uses only the JavaScript features that are supported by Yocto-JavaScript; for example, it disallows the function \mintinline{js}{(x, y) => x} because it has multiple parameters. The parser also checks that all variable references refer to variables that are defined; for example, it disallows the program \mintinline{js}{x => y} because \mintinline{js}{y} is undefined. Finally, the parser cleans the data structures generated by Esprima, removing information that the analyzer does not need, for example, the location information relating the data structures back to their corresponding segments in the original input string.

The following is the implementation of the Yocto-JavaScript parser:

\begin{minted}[linenos]{ts}
export function parse(input: string): Expression {
  const program = parseScript(input);
  if (program.body.length !== 1)
    throw new Error("‘Program’ has a ‘body’ whose length isn’t exactly one.");
  if (program.body[0].type !== "ExpressionStatement")
    throw new Error(
      "‘Program’ has a ‘body’ that isn’t an ‘ExpressionStatement’."
    );
  return checkAndClean(program.body[0].expression, new Set<string>());

  function checkAndClean(
    node: ESTree.Node,
    definedVariables: Set<string>
  ): Expression {
    switch (node.type) {
      case "ArrowFunctionExpression":
        if (node.params.length !== 1)
          throw new Error(
            "‘ArrowFunctionExpression’ doesn’t have exactly one ‘param’."
          );
        if (node.params[0].type !== "Identifier")
          throw new Error(
            "‘ArrowFunctionExpression’ has a ‘param’ that isn’t an ‘Identifier’."
          );
        return {
          type: node.type,
          params: [
            {
              type: node.params[0].type,
              name: node.params[0].name
            }
          ],
          body: checkAndClean(
            node.body,
            new Set([...definedVariables, node.params[0].name])
          )
        };
      case "CallExpression":
        if (node.arguments.length !== 1)
          throw new Error(
            "‘CallExpression’ doesn’t have exactly one ‘argument’."
          );
        return {
          type: node.type,
          callee: checkAndClean(node.callee, definedVariables),
          arguments: [checkAndClean(node.arguments[0], definedVariables)]
        };
      case "Identifier":
        if (!definedVariables.has(node.name))
          throw new Error(`Variable reference to ‘${node.name}’ not in scope.`);
        return {
          type: node.type,
          name: node.name
        };
      default:
        throw new Error(`Invalid node type: ‘${node.type}’.`);
    }
  }
}
\end{minted}

\begin{description}
\item [Line~1:]

The parser is defined as a function called \mintinline{ts}{parse()}, which receives the program to be parsed as a \mintinline{ts}{string} called \mintinline{ts}{input}, and produces an \mintinline{ts}{Expression} (see §~\ref{A Parser and Data Structures to Represent Yocto-JavaScript Programs} for the definition of \mintinline{ts}{Expression} and the other data structures generated by the Yocto-JavaScript parser).

\item [Line~2:]

Call the Esprima \mintinline{ts}{parseScript()} function which produces ESTree-compliant data structures for the program. This function throws an exception in case the \mintinline{ts}{input} has a syntax error; for example, \mintinline{js}{x =>}, which is missing the function body.

\item [Lines~3–8:]

Check whether the top-level \mintinline{ts}{program} is using only features supported by Yocto-JavaScript.

\begin{description}
\item [Lines~3–4:]

The \mintinline{ts}{program} must include only one \mintinline{ts}{Statement}; for example, \mintinline{js}{x => x; y => y} is disallowed.

\item [Lines~5–8:]

The sole \mintinline{ts}{Statement} must be an \mintinline{ts}{ExpressionStatement}; for example, \mintinline{js}{x => x} is allowed because it is an \mintinline{ts}{ExpressionStatement}, but \mintinline{js}{const f = x => x} is disallowed because it is a \mintinline{ts}{VariableDeclaration}.
\end{description}

\item [Line~9:]

Extract the sole \mintinline{ts}{Expression} from within the \mintinline{ts}{program}, which is the only part that the analyzer needs, and call the auxiliary function \mintinline{ts}{checkAndClean()} (see below).

\item [Lines~11–14:]

The \mintinline{ts}{checkAndClean()} auxiliary function traverses the data structures generated by Esprima to perform three tasks: check that the features used by the parsed program are supported by Yocto-JavaScript, check that all variable references are for variables which are defined, and remove information that the analyzer does not need. (This traversal is an example of something called \emph{syntax-directed translation}~\cite[§~2]{dragon-book}.)

The \mintinline{ts}{checkAndClean()} function receives two parameters: \mintinline{ts}{node}, which is a data structure generated by Esprima (so called because it forms a tree); and \mintinline{ts}{definedVariables}, which is a set of variables defined where \mintinline{ts}{node} appears and is used for checking variable references (see below).

\item [Lines~15, 16, 38, 48, 55, 33–36, 45–46:]

On a high level, the \mintinline{ts}{checkAndClean()} function works by detecting the type of \mintinline{ts}{Node} it is given (Lines~15, 16, 38, 48, 55), performing some checks (see below), and then calling itself recursively with parts of the \mintinline{ts}{node} (Lines~33–36, 45–46). The recursive calls guarantee that \mintinline{ts}{checkAndClean()} visits every part of the data structure.

\item [Lines~17–24, 39–42, 49–50, 56:]

After \mintinline{ts}{checkAndClean()} determines the type of \mintinline{ts}{node}, it checks whether the program is using only the features supported by Yocto-JavaScript, throwing an exception otherwise.

\begin{description}
\item [Lines~17–20:]

A function definition must include exactly one parameter; for example, \mintinline{js}{(x, y) => x} is disallowed.

\item [Lines~21–24:]

The parameter in a function definition must be an \mintinline{ts}{Identifier}; for example, \mintinline{js}{([x, y]) => x} is disallowed because the parameter is an \mintinline{ts}{ArrayPattern}.

\item [Lines~39–42:]

A function call must include exactly one argument; for example, \mintinline{js}{f => a => b => f(a, b)} is disallowed.

\item [Lines~49–50:]

Variable references must refer to variables that are defined (see below).

\item [Lines~56:]

Any type of \mintinline{ts}{Node} that has not been listed is not supported by Yocto-JavaScript, for example, \mintinline{ts}{29}, which is a \mintinline{ts}{Literal}.
\end{description}

\item [Lines~13, 9, 35, 45–46, 49:]

To check that all variable references refer to defined variables, the \mintinline{ts}{checkAndClean()} function maintains a set of \mintinline{ts}{definedVariables} (Line~13). This set starts empty (Line~9) and is augmented when encountering a function definition (Line~35). The set is then checked when encountering a variable reference (Line~49). Other types of \mintinline{ts}{Node} that are not related to either defining or referencing variables pass \mintinline{ts}{definedVariables} unchanged on the recursive calls to \mintinline{ts}{checkAndClean()}; in Yocto-JavaScript this only happens in one case, function calls (Lines~45–46), but in languages with more features most types of \mintinline{ts}{Node} are in this category, for example, those that would be produced by \mintinline{js}{+}, \mintinline{js}{-}, \mintinline{js}{if}, and so forth.

For an example of how \mintinline{ts}{checkAndClean()} detects a problem in a variable reference, consider the program \mintinline{js}{x => y}. The set \mintinline{ts}{definedVariables} starts empty and is augmented with \mintinline{js}{x} upon encountering the function definition, but then \mintinline{ts}{checkAndClean()} visits the variable reference to \mintinline{ts}{y} in the function body, which it cannot find in \mintinline{ts}{definedVariables}, and it throws an exception.

\item [Lines~25–37, 43–47, 51–54:]

To clean the data structures produced by Esprima and remove information that is not required by the analyzer, we explicitly reconstruct the data structures (see §~\ref{A Parser and Data Structures to Represent Yocto-JavaScript Programs}).
\end{description}

\backmatter

\bibliographystyle{plain}
\bibliography{\jobname}

\chapter{Biographical Statement}

% TODO

\end{document}
