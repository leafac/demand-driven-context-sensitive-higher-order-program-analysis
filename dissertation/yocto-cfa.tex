\documentclass[12pt, oneside]{book}

\usepackage[a-1b]{pdfx}
\hypersetup{hidelinks, bookmarksnumbered}
\usepackage{tocbibind}

\usepackage[top = 1in, right = 1in, bottom = 1in, left = 1.5in]{geometry}
\usepackage[doublespacing]{setspace}
\frenchspacing

\pagestyle{plain}

\usepackage{fontspec, unicode-math}
\setmainfont{Charter}
\setmonofont{Menlo}[Scale = 0.9]
\setmathfont{TeX Gyre Pagella Math}

\usepackage[framemethod = tikz, roundcorner = 3pt]{mdframed}

\usepackage{minted}
\usemintedstyle{vs}
\setminted{fontsize = \small, baselinestretch = 1}
\setmintedinline{fontsize = \normalsize}

\usepackage{graphicx, mathpartir}

\begin{document}

\frontmatter

\begin{center}
\begin{singlespace}
\vspace*{0.5in}

\textbf{\uppercase{Yocto-CFA}}

\vspace*{1in}

by\\Leandro Facchinetti

\vspace*{1.5in}

A dissertation submitted to Johns Hopkins University\\in conformity with the requirements for the degree of Doctor of Philosophy

\vspace*{0.5in}

Baltimore, Maryland\\August 2020
\end{singlespace}
\end{center}

\thispagestyle{empty}
\clearpage

\chapter{Abstract}

% TODO

\paragraph{Primary Reader and Advisor:}

Dr.~Scott Fraser Smith.

\paragraph{Readers:}

Dr.~Zachary Eli Palmer and Dr.~Matthew Daniel Green.

\chapter{Acknowledgements}

% TODO

\tableofcontents
\listoftables
\listoffigures

\mainmatter

% TODO: Introduction
% TODO: Link to GitHub

\chapter{Developing an Analyzer}

% TODO: An overview of the rest of the section

\section{The Analyzed Language: Yocto-JavaScript}
\label{The Analyzed Language: Yocto-JavaScript}

Our first decision when developing an analyzer is which language it should analyze. In this dissertation we are interested in analysis techniques for higher-order functions, a feature which is supported by most languages, including JavaScript, Java, Python, Ruby, and so forth.

From all these options, we would like to choose JavaScript because it is the most popular language among programmers~\cite{stack-overflow-developer-survey, jet-brains-developer-survey}, but JavaScript has many features besides higher-order functions that would complicate our analyzer, so we support only a \emph{subset} of JavaScript features that are related to higher-order functions, resulting in a language that we call \emph{Yocto-JavaScript} ($\mathrm{JavaScript} \times 10^{-24}$). By design, every Yocto-JavaScript program is also a JavaScript program, but the converse does not hold.

\begin{mdframed}[frametitle = {Advanced}]
On the surface the choice of analyzed language is important because it determines how difficult the analyzer is to develop, but the analyzed language may also influence the analyzer’s precision and running time. For example, there is an analysis technique called $k$-CFA~\cite{k-cfa} that may be slower when applied to a language with higher-order functions than when applied to a language with objects, because the algorithmic complexity of the former is exponential and of the latter is polynomial~\cite{m-cfa}.
\end{mdframed}

\begin{mdframed}[frametitle = {Technical Terms}]
Yocto-JavaScript is a representation of something called the \emph{$\lambda$-calculus}~\cite[§~6]{understanding-computation}.
\end{mdframed}

\subsection{Values in Yocto-JavaScript}
\label{Values in Yocto-JavaScript}

JavaScript has many kinds of values: strings (for example, \mintinline{js}{"Leandro"}), numbers (for example, \mintinline{js}{29}), arrays (for example, \mintinline{js}{["Leandro", 29]}), objects (for example, \mintinline{js}!{ name: "Leandro", age: 29 }!), and so forth. From all these kinds of values, Yocto-JavaScript supports only one: functions.

An Yocto-JavaScript function is written as \verb!<parameter> => <body>!, for example, \mintinline{js}{x => x}, in which the \verb!<parameter>! is called \mintinline{js}{x} and the \verb!<body>! is a reference to the variable \mintinline{js}{x} (see §~\ref{Operations in Yocto-JavaScript}). An Yocto-JavaScript function must have exactly one parameter. Because an Yocto-JavaScript function is a value, it may be passed as argument in a function call or returned as the result of a function call (see §~\ref{Operations in Yocto-JavaScript}).

\begin{mdframed}[frametitle = {Technical Terms}]
The notation we use for writing functions is something called \emph{arrow function expressions}~\cite{arrow-function-expressions}. The function given as example is called the \emph{identity} function. The ability of acting as values is what characterizes these functions as \emph{higher-order}.
\end{mdframed}

\subsection{Operations in Yocto-JavaScript}
\label{Operations in Yocto-JavaScript}

JavaScript has many operations: strings may have its characters accessed (for example, \mintinline{js}{"Leandro"[2]}, which results in \mintinline{js}{"a"}), numbers may be added together (for example, \mintinline{js}{29 + 1}, which results in \mintinline{js}{30}), and so forth. From all these operations, Yocto-JavaScript supports only two: functions may be called and variables may be referenced.

A function call is written as \verb!<function>(<argument>)!, for example, \mintinline{js}{f(a)}, in which the \verb!<function>! is a hypothetical function \mintinline{js}{f} and the \verb!<argument>! is a hypothetical argument \mintinline{js}{a}. An Yocto-JavaScript function call must have exactly one argument (because an Yocto-JavaScript function must have exactly one parameter; see §~\ref{Values in Yocto-JavaScript}). A variable reference is written as a bare identifier, for example, \mintinline{js}{x}.

The following is a complete Yocto-JavaScript program that exemplifies all the supported operations:

\begin{minted}{js}
(x => x)(y => y)
\end{minted}

This program is a function call in which the \verb!<function>! is \mintinline{js}{x => x} and the \verb!<argument>! is \mintinline{js}{y => y}. When called, an Yocto-JavaScript function returns the result of computing its \verb!<body>! and the \verb!<body>! of \mintinline{js}{x => x} is a reference to the variable \mintinline{js}{x}, so \mintinline{js}{x => x} is a function that returns its argument unchanged and the final result of the example above is \mintinline{js}{y => y}.

In general, all kinds of Yocto-JavaScript expressions (function definitions, function calls, and variable references) may appear in the \verb!<body>! of a function definition, or as the \verb!<function>! or \verb!<argument>! of a call (for example, in the program \mintinline{js}{(f(a))(b)} the function call \mintinline{js}{f(a)} appears as the \verb!<function>! of a call).

We use parentheses to resolve ambiguities on where function definitions start and end, and in which order operations are computed. For example, given hypothetical functions \mintinline{js}{f}, \mintinline{js}{g}, and \mintinline{js}{h}, in \mintinline{js}{(f(g))(h)} the call \mintinline{js}{f(g)} happens first and the result is a function that is called with \mintinline{js}{h}, and in \mintinline{js}{f(g(h))} the call \mintinline{js}{g(h)} happens first and the result is passed as argument to \mintinline{js}{f}.

\begin{mdframed}[frametitle = {Technical Terms}]
The order in which operations are computed is something called their \emph{precedence}, and operations that happen first are said to have \emph{higher precedence}.
\end{mdframed}

\begin{mdframed}[frametitle = {Advanced}]

\subsection{The Computational Power of Yocto-JavaScript}
\label{The Computational Power of Yocto-JavaScript}

Yocto-JavaScript has only a few features, which makes it the ideal language for discussing the analysis of higher-order functions, but is it \emph{too} simple? In other words, in the process of pairing down JavaScript to define Yocto-JavaScript, have we removed features that make the language incapable of some computations? Perhaps surprisingly, the answer is negative: Yocto-JavaScript is equivalent to JavaScript (and Java, Python, Ruby, and so forth) in the sense that, with some effort, any program in any one language may be translated into an equivalent program in any other language~\cite[§~6]{understanding-computation}.

As an example of how to carry out this translation, consider a JavaScript function of two parameters: \mintinline{js}{(x, y) => x}. This function is not supported by Yocto-JavaScript, which supports only functions of one parameter (see §~\ref{Values in Yocto-JavaScript}), but we may encode it as a function that receives the first parameter and returns another function that receives the second parameter: \mintinline{js}{x => (y => x)}. Similarly, we may encode a call with multiple arguments as a sequence of calls that passes one argument at a time, for example, \mintinline{js}{f(a, b)} may be encoded as \mintinline{js}{(f(a))(b)}.

\begin{mdframed}[frametitle = {Technical Terms}]
All the languages we are considering are said to be equivalent in terms of \emph{computational power}: they are all \emph{Turing complete}~\cite[§~7]{understanding-computation}. The translation technique for functions with multiple arguments is called \emph{currying}~\cite[page~163]{understanding-computation}.
\end{mdframed}

For our goal of exploring analysis techniques, we are concerned only with computational power, but it is worth noting that programmers may be more interested in other language properties: Does the language promote writing programs of higher quality? (It most probably does not~\cite{code-quality}.) Does the language improve productivity? Does the language work well for the domain of the problem? (For example, we would probably write an operating system in C and a web application in JavaScript, not the other way around.) Is the language more expressive than others? (Perhaps surprisingly, it is possible to make formal arguments about expressiveness without resorting to personal preference and anecdotal evidence~\cite{expressive-power}.) Despite having the same computational power as other languages, Yocto-JavaScript fares badly in these other aspects: it is remarkably unproductive and inexpressive.

\subsection{A Formal Grammar for Yocto-JavaScript}
\label{A Formal Grammar for Yocto-JavaScript}

The description of Yocto-JavaScript given so far has been informal; the following is a grammar in \emph{Backus–Naur Form}~(BNF)~\cite{bnf}~\cite[§~4.2]{dragon-book} that formalizes it:

\begin{center}
\begin{tabular}{rcll}
$e$ & ::= & $x\texttt{ => }e$ | $e\texttt{(}e\texttt{)}$ | $x$ & Expressions \\
$x$ & ::= & \emph{<A Valid JavaScript Identifier>} & Variables \\
\end{tabular}
\end{center}

\end{mdframed}

\section{The Analyzer Language: TypeScript}
\label{The Analyzer Language: TypeScript}

After choosing our analyzed language (Yocto-JavaScript; see §~\ref{The Analyzed Language: Yocto-JavaScript}), we must decide in which language to develop the analyzer itself. Our analyzed language is based on JavaScript, but that does not restrict our choice of language in which to develop the analyzer because the analyzer treats the analyzed program as data, so it could be developed in any language: JavaScript, Java, Python, Ruby, and so forth. Still, from all these options, JavaScript does offer some advantages: it is the most popular~\cite{stack-overflow-developer-survey, jet-brains-developer-survey}, and it includes convenient tools to manipulate JavaScript programs (and therefore Yocto-JavaScript programs as well; see §~\ref{Step 0: Parser} and §~\ref{Step 0: Prettifier}). But JavaScript lacks a way to express the \emph{types} of data structures, functions, and so forth, which we will need (for example, see §~\ref{Data Structures to Represent Yocto-JavaScript Programs}), so we choose to implement our analyzer in a JavaScript extension with support for types called \emph{TypeScript}~\cite{typescript, typescript-deep-dive, understanding-typescript}.

\section{Step 0: Substitution-Based Interpreter}
\label{Step 0: Substitution-Based Interpreter}

Having chosen the analyzed language (Yocto-JavaScript; see §~\ref{The Analyzed Language: Yocto-JavaScript}) and the language in which to develop the analyzer itself (TypeScript; see §~\ref{The Analyzer Language: TypeScript}), we are ready to start the series of steps in the development of the analyzer. The first Step is an interpreter that executes Yocto-JavaScript programs and produces the same outputs that would be produced a regular JavaScript interpreter. This is a good starting point for two reasons: first, this interpreter is the basis upon which we will build the analyzer; and second, the outputs of this interpreter are the ground truth against which we will validate the outputs of the analyzer.

\subsection{Architecture}
\label{Architecture}

Our interpreter is defined as a function called \mintinline{ts}{evaluate()}, which receives as parameter an Yocto-JavaScript program represented as a string and returns the result of running it.

\begin{mdframed}[frametitle = {Advanced}]
The \mintinline{ts}{evaluate()} function is named after a native JavaScript function called \mintinline{js}{eval()}, which is similar to \mintinline{ts}{evaluate()} but for JavaScript programs.
\end{mdframed}

The following are two examples of how we will be able to use \mintinline{ts}{evaluate()} by the end of this Step (the \mintinline{ts}{>} represents the console):

\begin{minted}{ts}
> evaluate("x => x")
"x => x"
> evaluate("(x => x)(y => y)")
"y => y"
\end{minted}

The implementation of \mintinline{ts}{evaluate()} is separated into three parts called \mintinline{ts}{parse()}, \mintinline{ts}{run()}, and \mintinline{ts}{prettify()}:

\begin{center}
\includegraphics{images/architecture.pdf}
\end{center}

\begin{minted}{ts}
export function evaluate(input: string): string {
  return prettify(run(parse(input)));
}
\end{minted}

The \mintinline{ts}{parse()} function prepares the \mintinline{ts}{input} for interpretation, converting it from a string into more convenient data structures (see §~\ref{Data Structures to Represent Yocto-JavaScript Programs}). The \mintinline{ts}{run()} function is responsible for the interpretation itself. The \mintinline{ts}{prettify()} function converts the outputs of \mintinline{ts}{run()} into a human-readable format. In the following sections we address the implementation of \mintinline{ts}{run()} first, deferring \mintinline{ts}{parse()} to §~\ref{Step 0: Parser} and \mintinline{ts}{prettify()} to §~\ref{Step 0: Prettifier}.

\subsection{Data Structures to Represent Yocto-JavaScript Programs}
\label{Data Structures to Represent Yocto-JavaScript Programs}

The \mintinline{ts}{evaluate()} function receives an Yocto-JavaScript program represented as a string (see §~\ref{Architecture}), which is convenient for humans to write and read, but inconvenient for \mintinline{ts}{run()} to manipulate directly, because \mintinline{ts}{run()} is concerned with the \emph{structure} of the program instead of the \emph{text}: from \mintinline{ts}{run()}’s perspective it does not matter, for example, whether a function is written as \mintinline{js}{x => x} or as \mintinline{js}{x=>x} (note the difference in spacing). So before \mintinline{ts}{run()} starts interpreting the program, \mintinline{ts}{parse()} transforms it from a string into more convenient data structures (see §~\ref{Step 0: Parser} for \mintinline{ts}{parse()}’s implementation).

The following are two examples of Yocto-JavaScript programs followed by the data structures used to represent them, first in a high-level graphical representation and then in an equivalent low-level textual representation:

\begin{minted}{ts}
> parse("x => x")
\end{minted}
\includegraphics{images/data-structures-to-represent-yocto-javascript-programs/function.pdf}
\begin{minted}{ts}
{
  "type": "ArrowFunctionExpression",
  "params": [
    {
      "type": "Identifier",
      "name": "x"
    }
  ],
  "body": {
    "type": "Identifier",
    "name": "x"
  }
}
\end{minted}

\begin{minted}{ts}
> parse("(x => x)(y => y)")
\end{minted}
\includegraphics{images/data-structures-to-represent-yocto-javascript-programs/call.pdf}
\begin{minted}{ts}
{
  "type": "CallExpression",
  "callee": {
    "type": "ArrowFunctionExpression",
    "params": [
      {
        "type": "Identifier",
        "name": "x"
      }
    ],
    "body": {
      "type": "Identifier",
      "name": "x"
    }
  },
  "arguments": [
    {
      "type": "ArrowFunctionExpression",
      "params": [
        {
          "type": "Identifier",
          "name": "y"
        }
      ],
      "body": {
        "type": "Identifier",
        "name": "y"
      }
    }
  ]
}
\end{minted}

We choose to represent Yocto-JavaScript programs with the data structures above because they follow a specification called ESTree~\cite{estree}, and by adhering to this specification we may reuse tools from the JavaScript ecosystem (see §~\ref{Step 0: Parser} and §~\ref{Step 0: Prettifier}).

In general, the data structures used to represent Yocto-JavaScript programs are of the following types (written as TypeScript types adapted from the ESTree types~\cite{estree-types} to include only the features supported by Yocto-JavaScript):

\begin{minted}{ts}
type Expression = ArrowFunctionExpression | CallExpression | Identifier;

interface ArrowFunctionExpression {
  type: "ArrowFunctionExpression";
  params: [Identifier];
  body: Expression;
}

interface CallExpression {
  type: "CallExpression";
  callee: Expression;
  arguments: [Expression];
}

interface Identifier {
  type: "Identifier";
  name: string;
}
\end{minted}

\begin{mdframed}[frametitle = {Advanced}]
The definitions above correspond to elements of the Yocto-JavaScript grammar (see §~\ref{A Formal Grammar for Yocto-JavaScript}); for example, \mintinline{ts}{Expression} corresponds to $e$.
\end{mdframed}

In later Steps almost everything about the interpreter will change, but the data structures used to represent Yocto-JavaScript programs will remain the same.

\subsection{Runner Structure}
\label{Runner Structure}

As mentioned in §~\ref{Data Structures to Represent Yocto-JavaScript Programs}, the \mintinline{ts}{run()} function receives as parameter an Yocto-JavaScript program represented as an \mintinline{ts}{Expression}. The \mintinline{ts}{run()} function is then responsible for interpreting the program and producing a value. In Yocto-JavaScript, the only kind of value is a function (see §~\ref{Values in Yocto-JavaScript}), so me start the implementation of \mintinline{ts}{run()} with the following (we use \mintinline{ts}{throw} as a placeholder for code that has not be written yet to prevent the TypeScript compiler from signaling type errors):

\begin{minted}{ts}
type Value = ArrowFunctionExpression;

function run(expression: Expression): Value {
  throw new Error("NOT IMPLEMENTED YET");
}
\end{minted}

The first thing that \mintinline{ts}{run()} has to do is determine which type of \mintinline{ts}{expression} it is given:

\begin{minted}[highlightlines = {2-9}]{ts}
function run(expression: Expression): Value {
  switch (expression.type) {
    case "ArrowFunctionExpression":
      throw new Error("NOT IMPLEMENTED YET");
    case "CallExpression":
      throw new Error("NOT IMPLEMENTED YET");
    case "Identifier":
      throw new Error("NOT IMPLEMENTED YET");
  }
}
\end{minted}

In the sections below we fill in these placeholders step by step by considering example programs of increasing complexity.

\subsection{An Expression That Already Is a Value}
\label{An Expression That Already Is a Value}

\begin{center}
\begin{tabular}{c|c|c}
\textbf{Example Program} & \textbf{Current Output} & \textbf{Desired Output} \\
\mintinline{js}{x => x} & \mintinline{text}{NOT IMPLEMENTED YET} & \mintinline{js}{x => x} \\
\end{tabular}
\end{center}

The \mintinline{ts}{expression} already is a \mintinline{ts}{Value}, so it may be returned unchanged:

\begin{minted}[highlightlines = {3}]{ts}
// run()
case "ArrowFunctionExpression":
  return expression;
\end{minted}

\subsection{A Call Involving Immediate Functions}
\label{A Call Involving Immediate Functions}

\begin{center}
\begin{tabular}{c|c|c}
\textbf{Example Program} & \textbf{Current Output} & \textbf{Desired Output} \\
\mintinline{js}{(x => x)(y => y)} & \mintinline{text}{NOT IMPLEMENTED YET} & \mintinline{js}{y => y} \\
\end{tabular}
\end{center}

Interpreting function calls is the main task of our interpreter. There are several techniques to do this and in this Step we use one of the simplest: when the interpreter encounters a function call, it substitutes the variable references in the body of the function that is called with the argument that is passed. This is similar to how we reason about functions in mathematics; for example, given the function $f(x) = x + 1$, we calculate $f(29)$ by substituting the references to $x$ in $f$ with the argument $29$: $f(29) = 29 + 1$. The implementation of this substitution technique starts in this section and will only be complete in §~\ref{Substitution in Function Calls}.

\begin{mdframed}[frametitle = {Technical Terms}]
This technique for interpreting function calls is what characterizes our interpreter in this Step as a \emph{substitution-based interpreter}.
\end{mdframed}

In the example we are considering both the function that is called (\mintinline{js}{x => x}) and the argument (\mintinline{js}{y => y}) are immediate functions, as opposed to being the result of other operations, so for now we may limit the interpreter to handle only this case:

\begin{minted}[highlightlines = {3-7}]{ts}
// run()
case "CallExpression":
  if (
    expression.callee.type !== "ArrowFunctionExpression" ||
    expression.arguments[0].type !== "ArrowFunctionExpression"
  )
    throw new Error("NOT IMPLEMENTED YET");
  throw new Error("NOT IMPLEMENTED YET");
\end{minted}

The function that is called in our example (\mintinline{js}{x => x}) returns the argument unchanged (see §~\ref{Operations in Yocto-JavaScript}), so the following is sufficient to make this specific case work:

\begin{minted}[highlightlines = {8-9}]{ts}
// run()
case "CallExpression":
  if (
    expression.callee.type !== "ArrowFunctionExpression" ||
    expression.arguments[0].type !== "ArrowFunctionExpression"
  )
    throw new Error("NOT IMPLEMENTED YET");
  const argument = expression.arguments[0];
  return argument;
\end{minted}

\subsection{Substitution in Function Definitions}
\label{Substitution in Function Definitions}

\begin{center}
\begin{tabular}{c|c|c}
\textbf{Example Program} & \textbf{Current Output} & \textbf{Desired Output} \\
\mintinline{js}{(x => z => x)(y => y)} & \mintinline{js}{y => y} & \mintinline{js}{z => y => y} \\
\end{tabular}
\end{center}

The implementation in §~\ref{A Call Involving Immediate Functions} works for the example given there, but it is far from working in general: it does not even consider the body of the called function, always returning the argument unchanged, which explains the current output of the example program above. What the interpreter must do is traverse the body of the called function looking for variable references and substituting them. We unpack the called function using something called \emph{destructuring assignment}~\cite{destructuring-assignment} and setup the traversal with an auxiliary function called \mintinline{ts}{substitute()}:

\begin{minted}[highlightlines = {8-11, 13-16}]{ts}
// run()
case "CallExpression":
  if (
    expression.callee.type !== "ArrowFunctionExpression" ||
    expression.arguments[0].type !== "ArrowFunctionExpression"
  )
    throw new Error("NOT IMPLEMENTED YET");
  const {
    params: [{ name: parameter }],
    body
  } = expression.callee;
  const argument = expression.arguments[0];
  return substitute(body);
  function substitute(expression: Expression): Value {
    throw new Error("NOT IMPLEMENTED YET");
  }
\end{minted}

Similar to \mintinline{ts}{run()} itself, \mintinline{ts}{substitute()} starts by determining which type of \mintinline{ts}{expression} is passed to it:

\begin{minted}[highlightlines = {2-9}]{ts}
function substitute(expression: Expression): Value {
  switch (expression.type) {
    case "ArrowFunctionExpression":
      throw new Error("NOT IMPLEMENTED YET");
    case "CallExpression":
      throw new Error("NOT IMPLEMENTED YET");
    case "Identifier":
      throw new Error("NOT IMPLEMENTED YET");
  }
}
\end{minted}

When \mintinline{ts}{substitute()} starts traversing the \mintinline{ts}{body}, the \mintinline{ts}{expression} is an \mintinline{ts}{ArrowFunctionExpression} (\mintinline{js}{z => x}), and we want substitution to proceed deeper to find and substitute \mintinline{js}{x}, so we call \mintinline{ts}{substitute()} recursively (we use a feature called \emph{spread syntax}~\cite{spread-syntax} to build an \mintinline{ts}{expression} based on the existing one with a new \mintinline{ts}{body}):

\begin{minted}[highlightlines = {3-6}]{ts}
// substitute()
case "ArrowFunctionExpression":
  return {
    ...expression,
    body: substitute(expression.body)
  };
\end{minted}

After this recursive call, \mintinline{ts}{substitute()} reaches the case in which the \mintinline{ts}{expression} is a variable reference (an \mintinline{ts}{Identifier}): \mintinline{js}{x}. When this happens, \mintinline{ts}{substitute()} performs the substitution by returning the \mintinline{ts}{argument}:

\begin{minted}[highlightlines = {3}]{ts}
// substitute()
case "Identifier":
  return argument;
\end{minted}

\subsection{Name Mismatch}

\begin{center}
\begin{tabular}{c|c|c}
\textbf{Example Program} & \textbf{Current Output} & \textbf{Desired Output} \\
\mintinline{js}{(x => z => z)(y => y)} & \mintinline{js}{z => y => y} & \mintinline{js}{z => z} \\
\end{tabular}
\end{center}

The implementation in §~\ref{Substitution in Function Definitions} succeeds in traversing the body of the called function, but it is substituting \emph{all} variable references, regardless of whether they refer to the parameter of the called function, which explains why in the example above it is substituting the \mintinline{js}{z} even though the parameter is \mintinline{js}{x}. To fix this, we check whether the variable reference matches the parameter, and if it does not then we prevent the substitution by retuning the variable reference unchanged:

\begin{minted}[highlightlines = {3}]{ts}
// substitute()
case "Identifier":
  if (expression.name !== parameter) return expression;
  return argument;
\end{minted}

This leads to a problem with the return type of \mintinline{ts}{substitute()}: it is no longer guaranteed to be a \mintinline{ts}{Value}, as declared in §~\ref{Substitution in Function Definitions}, but may be any type of \mintinline{ts}{Expression}, for example, variable references. We fix this by changing \mintinline{ts}{substitute()}’s return type:

\begin{minted}[highlightlines = {13-17}]{ts}
// run()
case "CallExpression":
  if (
    expression.callee.type !== "ArrowFunctionExpression" ||
    expression.arguments[0].type !== "ArrowFunctionExpression"
  )
    throw new Error("NOT IMPLEMENTED YET");
  const {
    params: [{ name: parameter }],
    body
  } = expression.callee;
  const argument = expression.arguments[0];
  const substitutedBody = substitute(body);
  if (substitutedBody.type !== "ArrowFunctionExpression")
    throw new Error("NOT IMPLEMENTED YET");
  return substitutedBody;
  function substitute(expression: Expression): Expression {
    // ...
  }
\end{minted}

\subsection{Name Reuse}

\begin{center}
\begin{tabular}{c|c|c}
\textbf{Example Program} & \textbf{Current Output} & \textbf{Desired Output} \\
\mintinline{js}{(x => x => x)(y => y)} & \mintinline{js}{x => y => y} & \mintinline{js}{x => x} \\
\end{tabular}
\end{center}

In the program above, there are two options for the variable reference \mintinline{js}{x} on the right of the second \mintinline{js}{=>}: it may refer to the first (outer) \mintinline{js}{x} on the left of the first \mintinline{js}{=>}, in which case the output of the program would be \mintinline{js}{x => y => y}; or it may refer to the second (inner) \mintinline{js}{x} on the left of the second \mintinline{js}{=>}, in which case the output of the program would be \mintinline{js}{x => x}:

\begin{center}
\includegraphics{images/shadowing.pdf}
\end{center}

Currently \mintinline{ts}{substitute()} is implementing Option~1, but this leads to a serious issue: we are not able to reason about the inner function \mintinline{js}{x => x} independently; we must know where it appears and whether a variable called \mintinline{js}{x} is already defined there.

\begin{mdframed}[frametitle = {Technical Terms}]
We say that the problem with Option~1 is that it defeats something called \emph{local reasoning}. We say that Option~2 exhibits a behavior called \emph{shadowing}, and that the outer \mintinline{js}{x} is \emph{shadowed} by the inner \mintinline{js}{x}, because there is no way to refer to the outer \mintinline{js}{x} from the body of the inner function.
\end{mdframed}

We avoid this issue by modifying \mintinline{ts}{substitute()} to implement the Option~2, which is also the choice of JavaScript and every other popular programming language. We change \mintinline{ts}{substitute()}’s behavior when encountering a function definition so that if the parameter of the function definition matches the parameter that \mintinline{ts}{subsitute()} is substituting, then \mintinline{ts}{subsitute()} returns the function unchanged, preventing further substitution (note that there is no recursive call to \mintinline{ts}{substitute()} in this case):

\begin{minted}[highlightlines = {3}]{ts}
// substitute()
case "ArrowFunctionExpression":
  if (expression.params[0].name === parameter) return expression;
  return {
    ...expression,
    body: substitute(expression.body)
  };
\end{minted}

\subsection{Substitution in Function Calls}
\label{Substitution in Function Calls}

\begin{center}
\begin{tabular}{c|c|c}
\textbf{Example Program} & \textbf{Current Output} & \textbf{Desired Output} \\
\mintinline{js}{(x => z => x(x))(y => y)} & \mintinline{text}{NOT IMPLEMENTED YET} & \mintinline{js}{z => (y => y)(y => y)} \\
\end{tabular}
\end{center}

This case is similar to §~\ref{Substitution in Function Definitions}: all \mintinline{ts}{substitute()} has to do is continue traversing the function call recursively:

\begin{minted}[highlightlines = {3-7}]{ts}
// substitute()
case "CallExpression":
  return {
    ...expression,
    callee: substitute(expression.callee),
    arguments: [substitute(expression.arguments[0])]
  };
\end{minted}

\subsection{An Argument That Is Not Immediate}
\label{An Argument That Is Not Immediate}

\begin{center}
\begin{tabular}{c|c|c}
\textbf{Example Program} & \textbf{Current Output} & \textbf{Desired Output} \\
\mintinline{js}{(x => z => x)((a => a)(y => y))} & \mintinline{text}{NOT IMPLEMENTED YET} & \mintinline{js}{z => y => y} \\
\end{tabular}
\end{center}

In all example programs we considered so far the argument to a function call was an immediate function definition, but in general arguments may be result of function calls themselves. We fix this by calling \mintinline{ts}{run()} recursively on the argument (we also remove the check that the argument is an immediate function definition; if it is, then the recursive call returns it unchanged; see §~\ref{An Expression That Already Is a Value}):

\begin{minted}[highlightlines = {3-4, 9}]{ts}
// run()
case "CallExpression":
  if (expression.callee.type !== "ArrowFunctionExpression")
    throw new Error("NOT IMPLEMENTED YET");
  const {
    params: [{ name: parameter }],
    body
  } = expression.callee;
  const argument = run(expression.arguments[0]);
  const substitutedBody = substitute(body);
  if (substitutedBody.type !== "ArrowFunctionExpression")
    throw new Error("NOT IMPLEMENTED YET");
  return substitutedBody;
  function substitute(expression: Expression): Expression {
    // ...
  }
\end{minted}

(In technical terms, this technique of calling \mintinline{ts}{run()} recursively to produce an immediate function characterizes the interpreter as \emph{big-step}.)

(We could have decided \emph{not} to call \mintinline{ts}{run()} recursively to interpret the argument into a value. In this case, the argument would only be interpreted if it was \emph{used}, either as a function (see §~\ref{A Function That Is Not Immediate}) or as the result of the program (see §~\ref{Continuing to Run After a Function Call}); for example, the result of the program above would be \mintinline{js}{z => ((a => a)(y => y))}. There are languages that do this, most notably Haskell, and they are called \emph{call-by-name}, or \emph{call-by-need}, the difference being that the an argument may be computed multiple times in a call-by-name language if it appears multiple times in the body of the called function, but in a call-by-need language an argument is guaranteed to be computed at most once. Yocto-JavaScript, JavaScript itself, and most other popular programming languages follow the approach presented in this section, which is known as \emph{call-by-value}~\cite{call-by-name-call-by-value-and-the-lambda-calculus}.)

\subsection{A Function That Is Not Immediate}
\label{A Function That Is Not Immediate}

\begin{center}
\begin{tabular}{c|c|c}
\textbf{Example Program} & \textbf{Current Output} & \textbf{Desired Output} \\
\mintinline{js}{((z => z)(x => x))(y => y)} & \mintinline{text}{NOT IMPLEMENTED YET} & \mintinline{js}{y => y} \\
\end{tabular}
\end{center}

This is the dual of §~\ref{An Argument That Is Not Immediate} for the called function, and the solution is the same: to call \mintinline{ts}{run()} recursively (we also remove the check of whether the function is immediate):

\begin{minted}[highlightlines = {6}]{ts}
// run()
case "CallExpression":
  const {
    params: [{ name: parameter }],
    body
  } = run(expression.callee);
  const argument = run(expression.arguments[0]);
  const substitutedBody = substitute(body);
  if (substitutedBody.type !== "ArrowFunctionExpression")
    throw new Error("NOT IMPLEMENTED YET");
  return substitutedBody;
  function substitute(expression: Expression): Expression {
    // ...
  }
\end{minted}

\subsection{Continuing to Run After a Function Call}
\label{Continuing to Run After a Function Call}

\begin{center}
\begin{tabular}{c|c|c}
\textbf{Example Program} & \textbf{Current Output} & \textbf{Desired Output} \\
\mintinline{js}{(x => (z => z)(x))(y => y)} & \mintinline{text}{NOT IMPLEMENTED YET} & \mintinline{js}{y => y} \\
\end{tabular}
\end{center}

This is similar to §~\ref{An Argument That Is Not Immediate} and §~\ref{A Function That Is Not Immediate}: the result of substitution may be not an immediate function but another call, and more work may be necessary to interpret it. We solve this with yet another recursive call to \mintinline{ts}{evaluate()} (we also remove yet another check, which allows us to inline the \mintinline{ts}{substitutedBody} variable):

\begin{minted}[highlightlines = {8}]{ts}
// run()
case "CallExpression":
  const {
    params: [{ name: parameter }],
    body
  } = run(expression.callee);
  const argument = run(expression.arguments[0]);
  return run(substitute(body));
  function substitute(expression: Expression): Expression {
    // ...
  }
\end{minted}

\subsection{A Reference to an Undefined Variable}

\begin{center}
\begin{tabular}{c|c|c}
\textbf{Example Program} & \textbf{Current Output} & \textbf{Desired Output} \\
\mintinline{js}{(x => y)(y => y)} & \mintinline{text}{NOT IMPLEMENTED YET} & \mintinline{text}{Reference to undefined variable: y} \\
\end{tabular}
\end{center}

The only case in which \mintinline{ts}{run()} may encounter a variable reference directly is if the referenced variable is undefined, otherwise \mintinline{ts}{substitute()} would have already substituted it (see §~\ref{A Call Involving Immediate Functions}–§~\ref{Continuing to Run After a Function Call}). In this case, we throw an exception:

\begin{minted}[highlightlines = {3}]{ts}
// run()
case "Identifier":
  throw new Error(`Reference to undefined variable: ${expression.name}`);
\end{minted}

Note that if the reference to an undefined variable occurs in the body of a function that is not called, then we do not reach the case addressed in this section and an exception is not thrown. For example, the result of running the program \mintinline{js}{x => y} is \mintinline{js}{x => y}, not an exception. This is consistent with JavaScript’s behavior.

\subsection{The Entire Runner}
\label{The Entire Runner}

The implementation of the \mintinline{ts}{run()} function is complete:

\begin{minted}[linenos]{ts}
function run(expression: Expression): Value {
  switch (expression.type) {
    case "ArrowFunctionExpression":
      return expression;
    case "CallExpression":
      const {
        params: [{ name: parameter }],
        body
      } = run(expression.callee);
      const argument = run(expression.arguments[0]);
      return run(substitute(body));
      function substitute(expression: Expression): Expression {
        switch (expression.type) {
          case "ArrowFunctionExpression":
            if (expression.params[0].name === parameter) return expression;
            return {
              ...expression,
              body: substitute(expression.body)
            };
          case "CallExpression":
            return {
              ...expression,
              callee: substitute(expression.callee),
              arguments: [substitute(expression.arguments[0])]
            };
          case "Identifier":
            if (expression.name !== parameter) return expression;
            return argument;
        }
      }
    case "Identifier":
      throw new Error(`Reference to undefined variable: ${expression.name}`);
  }
}
\end{minted}

\subsection{A Program That Does Not Terminate}

\begin{center}
\begin{tabular}{c|c|c}
\textbf{Example Program} & \textbf{Current Output} & \textbf{Desired Output} \\
\mintinline{js}{(f => f(f))(f => f(f))} & \mintinline{text}{DOES NOT TERMINATE} & \mintinline{text}{DOES NOT TERMINATE} \\
\end{tabular}
\end{center}

Yocto-JavaScript may express any program that a computer may run (see §~\ref{The Computational Power of Yocto-JavaScript}), and some programs do not terminate. Consider the first time that \mintinline{js}{run()} is called with the example program above. Both the called function and the argument are immediate functions (they are both the function \mintinline{js}{f => f(f)}), so the first two recursive calls to \mintinline{ts}{run()} (see §~\ref{The Entire Runner}, lines 9 and 10) return the functions unchanged. At this point, the \mintinline{ts}{parameter} is \mintinline{ts}{f}, the \mintinline{ts}{body} is \mintinline{js}{f(f)}, and the \mintinline{ts}{argument} is \mintinline{js}{f => f(f)}. The result of the call to \mintinline{ts}{substitute()} (see §~\ref{The Entire Runner}, line 11) is \mintinline{js}{(f => f(f))(f => f(f))}, which is the same as the initial program, so the recursive call to \mintinline{ts}{run()} (see §~\ref{The Entire Runner}, line 11) leads to an infinite loop.

This is what we expect from an interpreter, but not from an analyzer: we expect the analyzer to always terminate. In the next steps we will transform this interpreter to turn it into an analyzer, and one of the main issues we will address is termination.

\subsection{An Operational Semantics for the Interpreter}

What we accomplished in this section is more than defining an interpreter for Yocto-JavaScript; we also defined a formal specification of the \emph{semantics} of the Yocto-JavaScript language: an Yocto-JavaScript program means what the interpreter produces for it. This technique for defining the meaning of a language is called a \emph{definitional interpreter}~\cite{definitional-interpreters}.

Definitional interpreters have some advantages: they are easier to understand for most programmers, and they are executable. But definitional interpreters also have one disadvantage: to understand the meaning of an Yocto-JavaScript program we have to understand an interpreter written in TypeScript. To address this, there are other techniques for defining the semantics of a programming language that do not depend on another programming language. In this section we use one of these techniques called an \emph{operational semantics}~\cite{operational-semantics}.

The following is an operational semantics for Yocto-JavaScript:

\begin{center}
\begin{tabular}{rcll}
$v$ & ::= & $x\texttt{ => }e$ & Values \\
\end{tabular}
\end{center}

\begin{mathpar}
\inferrule
{ }
{v \Rightarrow v}

\inferrule
{
e_{f} \Rightarrow x_{p}\texttt{ => }e_{b} \\
e_{a} \Rightarrow v_{a} \\
e_{b}[x_{p} \backslash v_{a}] \Rightarrow v \\
}
{e_{f}\texttt{(}e_{a}\texttt{)} \Rightarrow v}
\end{mathpar}

\begin{tabular}{rcll}
$(x\texttt{ => }e)[x_{p} \backslash v_{a}]$ & = & $x\texttt{ => }(e[x_{p} \backslash v_{a}])$ & if $x \neq x_{p}$ \\
$(x_{p}\texttt{ => }e)[x_{p} \backslash v_{a}]$ & = & $x_{p}\texttt{ => }e$ & \\
$(e_{f}\texttt{(}e_{a}\texttt{)})[x_{p} \backslash v_{a}]$ & = & $(e_{f}[x_{p} \backslash v_{a}])\texttt{(}(e_{a}[x_{p} \backslash v_{a}])\texttt{)}$ & \\
$x[x_{p} \backslash v_{a}]$ & = & $x$ & if $x \neq x_{p}$ \\
$x_{p}[x_{p} \backslash v_{a}]$ & = & $v_{a}$ & \\
\end{tabular}

\subsection{Loader}
\label{Step 0: Parser}

% TODO: (This is a process called \emph{parsing}, and the data structures are called the \emph{Abstract Syntax Tree}~(AST) of the program~\cite[§~4]{dragon-book}.)
% TODO: \cite{esprima}, \cite{esprima-demonstration}

\begin{minted}[linenos]{ts}
function load(input: string): Expression {
  const program = parseScript(input, {}, verifyFeatures);
  const expression = (program as any).body[0].expression as Expression;
  return expression;
  function verifyFeatures(node: Node): void {
    switch (node.type) {
      case "Program":
        if (node.body.length !== 1)
          throw new Error(
            "Unsupported Yocto-JavaScript feature: Program with multiple statements"
          );
        break;
      case "ExpressionStatement":
        break;
      case "ArrowFunctionExpression":
        break;
      case "CallExpression":
        if (node.arguments.length !== 1)
          throw new Error(
            "Unsupported Yocto-JavaScript feature: CallExpression with multiple arguments"
          );
        break;
      case "Identifier":
        break;
      default:
        throw new Error(`Unsupported Yocto-JavaScript feature: ${node.type}`);
    }
  }
}
\end{minted}

\subsection{Unloader}
\label{Step 0: Prettifier}

% TODO: \cite{esprima} \cite{esprima-demonstration}

\begin{minted}{ts}
function unload(value: Value): string {
  return format(generate(value), { parser: "babel", semi: false }).trim();
}
\end{minted}

\appendix

\backmatter

\bibliographystyle{plain}
\bibliography{\jobname}

\chapter{Biographical Statement}

% TODO

\end{document}
