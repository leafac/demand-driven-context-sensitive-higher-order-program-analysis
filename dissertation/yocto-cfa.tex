% !TEX program = lualatex
% !TEX options = -shell-escape -synctex=1 -interaction=nonstopmode -file-line-error "%DOC%"
% !BIB program = bibtex

\documentclass[12pt, oneside]{book}

\usepackage[a-1b]{pdfx}
\hypersetup{hidelinks, bookmarksnumbered}
\usepackage{tocbibind}

\usepackage[top = 1in, right = 1in, bottom = 1in, left = 1.5in]{geometry}
\usepackage[doublespacing]{setspace}

\pagestyle{plain}

\usepackage{fontspec, unicode-math}
\setmainfont{XCharter}
\setmonofont{FiraMono}[Scale = 0.9]
\setmathfont{TeX Gyre Pagella Math}

\usepackage{minted}
\usemintedstyle{vs}
\setminted{fontsize = \small, baselinestretch = 1}
\setmintedinline{fontsize = \normalsize}

\begin{document}

\frontmatter

\begin{center}
\begin{singlespace}
\vspace*{0.5in}

\textbf{\uppercase{Yocto-CFA}}

\vspace*{1in}

by

Leandro Facchinetti

\vspace*{1.5in}

A dissertation submitted to Johns Hopkins University\\in conformity with the requirements for the degree of Doctor of Philosophy

\vspace*{0.5in}

Baltimore, Maryland

August 2020
\end{singlespace}
\end{center}

\thispagestyle{empty}
\clearpage

\chapter{Abstract}

% TODO

\paragraph{Primary Reader and Advisor:}

Dr.~Scott Fraser Smith.

\paragraph{Readers:}

Dr.~Zachary Eli Palmer and Dr.~Matthew Daniel Green.

\chapter{Acknowledgements}

% TODO

\tableofcontents
\listoftables
\listoffigures

\mainmatter

% TODO: Introduction
% TODO: Link to GitHub

\chapter{Developing an Analyzer}

% TODO: An overview of the rest of the section

\section{The Analyzed Language: Yocto-JavaScript}
\label{The Analyzed Language: Yocto-JavaScript}

Our first decision when developing an analyzer is which language it should analyze. This is important because the analyzed language influences how difficult it is to build the analyzer, and it may also affect the analyzer’s precision and running time. For example, there is an analysis technique called $k$-CFA~\cite{k-cfa} that may be slower when applied to a language with higher-order functions than when applied to a language with objects (the algorithmic complexity of the former is exponential; of the latter, polynomial)~\cite{m-cfa}.

In this dissertation we are interested in analysis techniques for higher-order functions. Fortunately, most languages support higher-order functions, so we have plenty of options: JavaScript, Java, Python, Ruby, and so forth. From all these languages, we choose JavaScript because it is the most popular~\cite{stack-overflow-developer-survey, jet-brains-developer-survey}.

Unfortunately, JavaScript is a big language with many features besides higher-order functions, and an analyzer that tried to support all of them would be too complex. We address this issue by defining our own artificial little language based on a subset of JavaScript features related to higher-order functions, which we call \emph{Yocto-JavaScript} ($\mathrm{JavaScript} \times 10^{-24}$). By design, every Yocto-JavaScript program is also a JavaScript program, but the converse does not hold.

(In technical terms, we say that Yocto-JavaScript is a representation of something called the \emph{call-by-value $\lambda$-calculus}~\cite[§~6]{understanding-computation}).)

\subsection{Values in Yocto-JavaScript}
\label{Values in Yocto-JavaScript}

JavaScript has many kinds of values: strings (for example, \mintinline{js}{"Leandro"}), numbers (for example, \mintinline{js}{29}), arrays (for example, \mintinline{js}{["Leandro", 29]}), objects (for example, \mintinline{js}!{ name: "Leandro", age: 29 }!), and so forth. From all these kinds of values, Yocto-JavaScript only supports one: functions.

An Yocto-JavaScript function is written as \verb!<parameter> => <body>!, for example, \mintinline{js}{x => x}, in which the \verb!<parameter>! is called \mintinline{js}{x} and the \verb!<body>! is simply a reference to the variable \mintinline{js}{x} (see §~\ref{Operations in Yocto-JavaScript} for more on variable references). Because an Yocto-JavaScript function is a value, it may be passed as argument in a function call, or returned as the result of a function call (see §~\ref{Operations in Yocto-JavaScript} for more on function calls). (This notation for writing functions is something called \emph{arrow function expressions}~\cite{arrow-function-expressions}. The function given as example is called the \emph{identity} function. The ability of acting as values is what characterizes these functions as \emph{higher-order}.)

An Yocto-JavaScript function must have exactly one parameter.

\subsection{Operations in Yocto-JavaScript}
\label{Operations in Yocto-JavaScript}

JavaScript has many operations: strings may have its characters accessed (for example, \mintinline{js}{"Leandro"[2]}), numbers may be added together (for example, \mintinline{js}{29 + 1}), and so forth. From all these operations, Yocto-JavaScript only supports two: functions may be called and variables may be referenced.

A function call is written as \verb!<function>(<argument>)!, for example, \mintinline{js}{f(a)}, in which the \verb!<function>! is a hypothetical function \mintinline{js}{f} and the \verb!<argument>! is a hypothetical argument \mintinline{js}{a}.

An Yocto-JavaScript function call must have exactly one argument (because an Yocto-JavaScript function must have exactly one parameter; see §~\ref{Values in Yocto-JavaScript}).

A variable reference is written as a bare identifier, for example, \mintinline{js}{x}.

The following is a complete Yocto-JavaScript program that exemplifies all the supported operations:

\begin{minted}{js}
(x => x)(y => y)
\end{minted}

This program is a function call in which the \verb!<function>! is \mintinline{js}{x => x} and the \verb!<argument>! is \mintinline{js}{y => y}. When called, an Yocto-JavaScript function returns the result of computing its \verb!<body>!, and the \verb!<body>! of \mintinline{js}{x => x} is simply a reference to the variable \mintinline{js}{x}, so \mintinline{js}{x => x} is a function that returns its argument unchanged, and the final result of the example above is \mintinline{js}{y => y}.

In general, all kinds of Yocto-JavaScript expressions (function definitions, function calls, and variable references) may appear in the \verb!<body>! of a function definition, or as the \verb!<function>! or \verb!<argument>! of a call.

We use parentheses to resolve ambiguities on where function definitions start and end, and in which order operations are computed (something called the \emph{precedence} of the operations). For example, there are at least two ways in which hypothetical functions \mintinline{js}{f}, \mintinline{js}{g}, and \mintinline{js}{h} may call one another: \mintinline{js}{(f(g))(h)}, in which case \mintinline{js}{f(g)} happens first, and the result is a function that is called with \mintinline{js}{h}; and \mintinline{js}{f(g(h))}, in which case \mintinline{js}{g(h)} happens first, and the result is passed as argument to \mintinline{js}{f}.

\subsection{The Computational Power of Yocto-JavaScript}

Yocto-JavaScript has very few features, which makes it the ideal language for discussing the analysis of higher-order functions, but is it \emph{too} simple? Is there something that we may compute in JavaScript (or Java, Python, Ruby, and so forth) that is impossible to compute in Yocto-JavaScript? Perhaps surprisingly, the answer is negative: all these languages are equivalent in the sense that, with some effort, any program in any one language may be translated into an equivalent program in any other language~\cite[§~6]{understanding-computation}. (We say that these languages are equivalent in \emph{computational power}: they are all \emph{Turing complete}~\cite[§~7]{understanding-computation}. For our goal of exploring analysis techniques, we are concerned only with computational power, but it is worth noting that from a programmer’s perspective the features that a language supports (its \emph{expressive power}~\cite{expressive-power}) are more important, because they indicate how convenient the language is to use. Yocto-JavaScript is remarkably inexpressive, and therefore inconvenient for programming.)

As an example of how to carry out the translation from a real-world language into Yocto-JavaScript, consider a JavaScript function of two parameters: \mintinline{js}{(x, y) => x}. This function is not supported by Yocto-JavaScript, which only supports functions of one parameter (see §~\ref{Values in Yocto-JavaScript}), but we may encode it as a function that receives the first parameter and returns another function that receives the second parameter: \mintinline{js}{x => (y => x)}. Similarly, we may encode a call with multiple arguments as a sequence of calls that passes one argument at a time; for example, we may encode \mintinline{js}{f(a, b)} as \mintinline{js}{(f(a))(b)}. (This technique is called \emph{currying}.)

\subsection{A Formal Grammar for Yocto-JavaScript}
\label{A Formal Grammar for Yocto-JavaScript}

The description of Yocto-JavaScript given so far is informal; the following is a grammar that formalizes it (using \emph{Backus–Naur Form}~(BNF)~\cite{bnf}~\cite[§~4.2]{dragon-book}):

\begin{center}
\begin{tabular}{rcll}
$e$ & ::= & $x\texttt{ => }e$ | $e\texttt{(}e\texttt{)}$ | $x$ & Expressions \\
$x$ & ::= & \emph{<A Valid JavaScript Identifier>} & Variables \\
\end{tabular}
\end{center}

\section{The Analyzer Language: TypeScript}
\label{The Analyzer Language: TypeScript}

After choosing our analyzed language (Yocto-JavaScript; see §~\ref{The Analyzed Language: Yocto-JavaScript}), we must decide in which language to develop the analyzer itself. Our analyzed language is based on JavaScript, but the analyzer may be developed in any language (JavaScript, Java, Python, Ruby, and so forth) because it simply treats the analyzed program as data. Yet, from all these options, JavaScript does offer some advantages: it is the most popular~\cite{stack-overflow-developer-survey, jet-brains-developer-survey}, and it includes convenient tools to manipulate JavaScript programs (and therefore Yocto-JavaScript programs as well; see §~\ref{Step 0: Loader} and §~\ref{Step 0: Unloader}). But JavaScript lacks a way to express the \emph{types} of data structures, functions, and so forth, which we will need (for example, see §~\ref{Data Structures to Represent Yocto-JavaScript Programs}), so we choose to implement our analyzer in a JavaScript extension with support for types called \emph{TypeScript}~\cite{typescript, typescript-deep-dive, understanding-typescript}.

\section{Step 0: Substitution-Based Interpreter}
\label{Step 0: Substitution-Based Interpreter}

Having chosen the analyzed language (Yocto-JavaScript; see §~\ref{The Analyzed Language: Yocto-JavaScript}) and the language in which to develop the analyzer itself (TypeScript; see §~\ref{The Analyzer Language: TypeScript}), we are ready to start the series of steps in the development of the analyzer. The first Step is an interpreter that simply executes Yocto-JavaScript programs and produces the same outputs that would be produced a regular JavaScript interpreter. This is a good starting point for two reasons: first, this interpreter is the basis upon which we will build the analyzer; and second, the outputs of this interpreter are the ground truth against which we will validate the outputs of the analyzer.

\subsection{Architecture}
\label{Architecture}

Our interpreter is defined as a function called \mintinline{ts}{evaluate()}, which receives as parameter an Yocto-JavaScript program represented as a string and returns the result of running it. (The \mintinline{ts}{evaluate()} function is named after a native JavaScript function called \mintinline{js}{eval()}, which is similar to \mintinline{ts}{evaluate()} but for JavaScript programs.)

The following are two examples of how we will be able to use \mintinline{ts}{evaluate()} by the end of this Step (the \mintinline{ts}{>} represents the console):

\begin{minted}{ts}
> evaluate("x => x")
"x => x"
> evaluate("(x => x)(y => y)")
"y => y"
\end{minted}

The implementation of \mintinline{ts}{evaluate()} is separated in three parts called \mintinline{ts}{load()}, \mintinline{ts}{run()}, and \mintinline{ts}{unload()}:

\begin{minted}{ts}
export function evaluate(input: string): string {
  return unload(run(load(input)));
}
\end{minted}

The \mintinline{ts}{load()} function prepares the \mintinline{ts}{input} for interpretation, for example, converting it from a string into more convenient data structures (see §~\ref{Data Structures to Represent Yocto-JavaScript Programs}). The \mintinline{ts}{run()} function is responsible for the interpretation itself. The \mintinline{ts}{unload()} function converts the outputs of \mintinline{ts}{run()} into a human-readable format. In later steps the implementation of \mintinline{ts}{load()}, \mintinline{ts}{run()}, and \mintinline{ts}{unload()} will change, but the architecture and therefore the implementation of \mintinline{ts}{evaluate()} will remain the same. In the following sections we address the implementation of \mintinline{ts}{run()} first, deferring \mintinline{ts}{load()} to §~\ref{Step 0: Loader} and \mintinline{ts}{unload()} to §~\ref{Step 0: Unloader}.

\subsection{Data Structures to Represent Yocto-JavaScript Programs}
\label{Data Structures to Represent Yocto-JavaScript Programs}

The \mintinline{ts}{evaluate()} function receives an Yocto-JavaScript program represented as a string (see §~\ref{Architecture}). While a string is convenient for humans to write and read, it would be inconvenient for \mintinline{ts}{run()} to manipulate directly, because \mintinline{ts}{run()} is concerned with the \emph{structure} of the program instead of its \emph{text}: from \mintinline{ts}{run()}’s perspective it does not matter, for example, whether a function is written as \mintinline{js}{x => x} or as \mintinline{js}{x=>x} (note the difference in spacing). So before \mintinline{ts}{run()} starts interpreting the program, \mintinline{ts}{load()} transforms it from a string into more convenient data structures (see §~\ref{Step 0: Loader} for \mintinline{ts}{load()}’s implementation).

The following are two examples of Yocto-JavaScript programs followed by the data structures used to represent them:

\begin{minted}{ts}
x => x

{
  "type": "ArrowFunctionExpression",
  "params": [
    {
      "type": "Identifier",
      "name": "x"
    }
  ],
  "body": {
    "type": "Identifier",
    "name": "x"
  }
}

(x => x)(y => y)

{
  "type": "CallExpression",
  "callee": {
    "type": "ArrowFunctionExpression",
    "params": [
      {
        "type": "Identifier",
        "name": "x"
      }
    ],
    "body": {
      "type": "Identifier",
      "name": "x"
    }
  },
  "arguments": [
    {
      "type": "ArrowFunctionExpression",
      "params": [
        {
          "type": "Identifier",
          "name": "y"
        }
      ],
      "body": {
        "type": "Identifier",
        "name": "y"
      }
    }
  ]
}
\end{minted}

We choose to represent Yocto-JavaScript programs with the data structures above because they follow a specification called ESTree~\cite{estree}, and by adhering to this specification we may reuse tools from the JavaScript ecosystem (see §~\ref{Step 0: Loader} and §~\ref{Step 0: Unloader}).

In general, the data structures used to represent Yocto-JavaScript programs are of the following types (written as TypeScript types adapted from the ESTree types~\cite{estree-types} to include only the features supported by Yocto-JavaScript):

\begin{minted}{ts}
type Expression = ArrowFunctionExpression | CallExpression | Identifier;

interface ArrowFunctionExpression {
  type: "ArrowFunctionExpression";
  params: [Identifier];
  body: Expression;
}

interface CallExpression {
  type: "CallExpression";
  callee: Expression;
  arguments: [Expression];
}

interface Identifier {
  type: "Identifier";
  name: string;
}
\end{minted}

(The definitions above correspond to elements of the Yocto-JavaScript grammar (see §~\ref{A Formal Grammar for Yocto-JavaScript}); for example, \mintinline{ts}{Expression} corresponds to $e$.)

In later steps various aspects of the interpreter will change, including parts of \mintinline{ts}{load()}, \mintinline{ts}{run()}, and \mintinline{ts}{unload()}, but the data structures used to represent Yocto-JavaScript programs will remain the same.

\subsection{Runner Structure}
\label{Runner Structure}

As mentioned in §~\ref{Data Structures to Represent Yocto-JavaScript Programs}, the \mintinline{ts}{run()} function receives as parameter an Yocto-JavaScript program represented as an \mintinline{ts}{Expression}. The \mintinline{ts}{run()} function is then responsible for interpreting the program and producing a value. In Yocto-JavaScript, the only kind of value is a function (see §~\ref{Values in Yocto-JavaScript}), so me start the implementation of \mintinline{ts}{run()} with the following (we use \mintinline{ts}{throw} as a placeholder for code that has not be written yet to prevent the TypeScript compiler from signaling type errors):

\begin{minted}{ts}
type Value = ArrowFunctionExpression;

function run(expression: Expression): Value {
  throw new Error("NOT IMPLEMENTED YET");
}
\end{minted}

The first thing that \mintinline{ts}{run()} has to do is determine which type of \mintinline{ts}{expression} it is given:

\begin{minted}[highlightlines = {2-9}]{ts}
function run(expression: Expression): Value {
  switch (expression.type) {
    case "ArrowFunctionExpression":
      throw new Error("NOT IMPLEMENTED YET");
    case "CallExpression":
      throw new Error("NOT IMPLEMENTED YET");
    case "Identifier":
      throw new Error("NOT IMPLEMENTED YET");
  }
}
\end{minted}

In the sections below we fill in these placeholders step by step by considering example programs of increasing complexity.

\subsection{An Expression That Already Is a Value}

\paragraph{Example program:}

\begin{minted}{js}
x => x
\end{minted}

\paragraph{Current output:}

\begin{minted}{text}
NOT IMPLEMENTED YET
\end{minted}

\paragraph{Desired output:}

\begin{minted}{js}
x => x
\end{minted}

\paragraph{}

The \mintinline{ts}{expression} already is a \mintinline{ts}{Value}, so it may be returned unchanged:

\begin{minted}[highlightlines = {3}]{ts}
// run()
case "ArrowFunctionExpression":
  return expression;
\end{minted}

\subsection{A Call Involving Immediate Functions}
\label{A Call Involving Immediate Functions}

\paragraph{Example program:}

\begin{minted}{js}
(x => x)(y => y)
\end{minted}

\paragraph{Current output:}

\begin{minted}{text}
NOT IMPLEMENTED YET
\end{minted}

\paragraph{Desired output (see §~\ref{Operations in Yocto-JavaScript}):}

\begin{minted}{js}
y => y
\end{minted}

\paragraph{}

Interpreting function calls is the main task of our interpreter. There are several techniques to do this and in this Step we use one of the simplest: when the interpreter encounters a function call, it substitutes the variable references in the body of the function that is called with the argument that is provided. This is similar to how we reason about functions in mathematics; for example, given the function $f(x) = x + 1$, we calculate $f(29)$ by substituting the references to $x$ in $f$ with the argument $29$: $f(29) = 29 + 1$. (This is something called a \emph{substitution-based interpreter}.)

In the example we are considering both the function that is called (\mintinline{js}{x => x}) and the argument (\mintinline{js}{y => y}) are immediate functions, as opposed to being the result of other operations (for example, consider \mintinline{js}{g(f(a))}, in which the argument to \mintinline{js}{g} is the result of the function call \mintinline{js}{f(a)}). For now we may limit the interpreter to handle only the case of immediate functions:

\begin{minted}[highlightlines = {3-7}]{ts}
// run()
case "CallExpression":
  if (
    expression.callee.type !== "ArrowFunctionExpression" ||
    expression.arguments[0].type !== "ArrowFunctionExpression"
  )
    throw new Error("NOT IMPLEMENTED YET");
  throw new Error("NOT IMPLEMENTED YET");
\end{minted}

The function that is called in our example (\mintinline{js}{x => x}) simply returns the argument unchanged (see §~\ref{Operations in Yocto-JavaScript}), so the following is sufficient to make the interpreter work for now:

\begin{minted}[highlightlines = {8-9}]{ts}
// run()
case "CallExpression":
  if (
    expression.callee.type !== "ArrowFunctionExpression" ||
    expression.arguments[0].type !== "ArrowFunctionExpression"
  )
    throw new Error("NOT IMPLEMENTED YET");
  const argument = expression.arguments[0];
  return argument;
\end{minted}

\subsection{Substitution in Function Definitions}
\label{Substitution in Function Definitions}

\paragraph{Example program:}

\begin{minted}{js}
(x => z => x)(y => y)
\end{minted}

\paragraph{Current output:}

\begin{minted}{js}
y => y
\end{minted}

\paragraph{Desired output:}

\begin{minted}{js}
z => y => y
\end{minted}

\paragraph{}

The implementation in §~\ref{A Call Involving Immediate Functions} works for the example given there, but it is far from working in general: it does not even consider the body of the called function, always returning the argument unchanged, which explains the current output of the example program above. What the interpreter must do is traverse the body of the called function looking for relevant variable references and substitute them. We unpack the called function using something called \emph{destructuring assignment}~\cite{destructuring-assignment} and implement this traversal with an auxiliary function called \mintinline{ts}{substitute()}:

\begin{minted}[highlightlines = {8-11, 13-16}]{ts}
// run()
case "CallExpression":
  if (
    expression.callee.type !== "ArrowFunctionExpression" ||
    expression.arguments[0].type !== "ArrowFunctionExpression"
  )
    throw new Error("NOT IMPLEMENTED YET");
  const {
    params: [{ name: parameter }],
    body
  } = expression.callee;
  const argument = expression.arguments[0];
  return substitute(body);
  function substitute(expression: Expression): Value {
    throw new Error("NOT IMPLEMENTED YET");
  }
\end{minted}

Similar to \mintinline{ts}{run()} itself, \mintinline{ts}{substitute()} starts by determining which type of \mintinline{ts}{expression} is passed to it:

\begin{minted}[highlightlines = {2-9}]{ts}
function substitute(expression: Expression): Value {
  switch (expression.type) {
    case "ArrowFunctionExpression":
      throw new Error("NOT IMPLEMENTED YET");
    case "CallExpression":
      throw new Error("NOT IMPLEMENTED YET");
    case "Identifier":
      throw new Error("NOT IMPLEMENTED YET");
  }
}
\end{minted}

When \mintinline{ts}{substitute()} starts traversing the \mintinline{ts}{body}, the \mintinline{ts}{expression} is an \mintinline{ts}{ArrowFunctionExpression} (\mintinline{js}{z => x}), and we want substitution to proceed deeper to find and substitute \mintinline{js}{x}, so we call \mintinline{ts}{substitute()} recursively (we use a feature called \emph{spread syntax}~\cite{spread-syntax} to build an \mintinline{ts}{expression} based on the existing one with a new \mintinline{ts}{body}):

\begin{minted}[highlightlines = {3-6}]{ts}
// substitute()
case "ArrowFunctionExpression":
  return {
    ...expression,
    body: substitute(expression.body)
  };
\end{minted}

After this recursive call, \mintinline{ts}{substitute()} reaches the case in which the \mintinline{ts}{expression} is a variable reference (an \mintinline{ts}{Identifier}): \mintinline{js}{x}. When this happens, \mintinline{ts}{substitute()} performs the substitution by returning the \mintinline{ts}{argument}:

\begin{minted}[highlightlines = {3}]{ts}
// substitute()
case "Identifier":
  return argument;
\end{minted}

\subsection{Name Mismatch}

\paragraph{Example program:}

\begin{minted}{js}
(x => z => z)(y => y)
\end{minted}

\paragraph{Current output:}

\begin{minted}{js}
z => y => y
\end{minted}

\paragraph{Desired output:}

\begin{minted}{js}
z => z
\end{minted}

\paragraph{}

The implementation in §~\ref{Substitution in Function Definitions} succeeds in traversing the body of the called function, but it is substituting \emph{all} variable references, regardless of whether they refer to the parameter of the called function, which explains why it is substituting the \mintinline{js}{z} in the body even though the parameter is \mintinline{js}{x}. To fix this, we simply check whether the variable reference matches the parameter, and if it does not we prevent substitution from happening by retuning the variable reference unchanged:

\begin{minted}[highlightlines = {3}]{ts}
// substitute()
case "Identifier":
  if (expression.name !== parameter) return expression;
  return argument;
\end{minted}

But this leads to a problem with the type of \mintinline{ts}{substitute()}: it is no longer guaranteed to return a \mintinline{ts}{Value}, as declared in §~\ref{Substitution in Function Definitions}, but may return any type of \mintinline{ts}{Expression}, for example, variable references. We fix this by changing \mintinline{ts}{substitute()}’s return type:

\begin{minted}[highlightlines = {13-17}]{ts}
// run()
case "CallExpression":
  if (
    expression.callee.type !== "ArrowFunctionExpression" ||
    expression.arguments[0].type !== "ArrowFunctionExpression"
  )
    throw new Error("NOT IMPLEMENTED YET");
  const {
    params: [{ name: parameter }],
    body
  } = expression.callee;
  const argument = expression.arguments[0];
  const substitutedBody = substitute(body);
  if (substitutedBody.type !== "ArrowFunctionExpression")
    throw new Error("NOT IMPLEMENTED YET");
  return substitutedBody;
  function substitute(expression: Expression): Expression {
    // ...
  }
\end{minted}

% STOPPED HERE
% TODO: Change \paragraph{} to \noindent\textbf{} or maybe even better: a table with minted within.

\subsection{Name Reuse}

\paragraph{Example program:}

\begin{minted}{js}
(x => x => x)(y => y)
\end{minted}

\paragraph{Current output:}

\begin{minted}{js}
x => y => y
\end{minted}

\paragraph{Desired output:}

\begin{minted}{js}
x => x
\end{minted}

\paragraph{}

In the program above, there are two options for the variable reference \mintinline{js}{x} on the right of the second \mintinline{js}{=>}: it may refer to the first (outer) \mintinline{js}{x} on the left of the first \mintinline{js}{=>}, in which case the output of the program would be \mintinline{js}{x => y => y}; or it may refer to the second (inner) \mintinline{js}{x} on the left of the second \mintinline{js}{=>}, in which case the output of the program would be \mintinline{js}{x => x}. (In technical terms, we say that the second option exhibits a behavior called \emph{shadowing}, in which the outer \mintinline{js}{x} is \emph{shadowed} by the inner \mintinline{js}{x} because there is no way to refer to the outer \mintinline{js}{x}.)

Currently \mintinline{ts}{substitute()} is implementing the first option, but this leads to a serious issue: we are not able to reason about the inner function \mintinline{js}{x => x} independently; we must know where it appears and whether a variable called \mintinline{js}{x} is already defined there. (In technical terms, we say that this defeats something called \emph{local reasoning}.)

We avoid this issue by modifying \mintinline{ts}{substitute()} to implement the second option, which is also implemented by JavaScript and every other popular programming language. We change \mintinline{ts}{substitute()}’s behavior when encountering a function definition: if the parameter of the function definition matches the parameter that \mintinline{ts}{subsitute()} is substituting, then it simply returns the function unchanged, preventing further substitution (note that there is no recursive call to \mintinline{ts}{substitute()} in that case):

\begin{minted}[highlightlines = {3}]{ts}
// substitute()
case "ArrowFunctionExpression":
  if (expression.params[0].name === parameter) return expression;
  return {
    ...expression,
    body: substitute(expression.body)
  };
\end{minted}

\subsection{Substitution in Function Calls}

\paragraph{Example program:}

\begin{minted}{js}
(x => z => x(x))(y => y)
\end{minted}

\paragraph{Current output:}

\begin{minted}{text}
NOT IMPLEMENTED YET
\end{minted}

\paragraph{Desired output:}

\begin{minted}{js}
z => (y => y)(y => y)
\end{minted}

\paragraph{}

This case is similar to §~\ref{Substitution in Function Definitions}: all \mintinline{ts}{substitute()} has to do is continue traversing the function call recursively:

\begin{minted}[highlightlines = {3-7}]{ts}
// substitute()
case "CallExpression":
  return {
    ...expression,
    callee: substitute(expression.callee),
    arguments: [substitute(expression.arguments[0])]
  };
\end{minted}

\subsection{An Argument That Is Not Immediate}
\label{An Argument That Is Not Immediate}

\paragraph{Example program:}

\begin{minted}{js}
(x => x)((z => z)(y => y))
\end{minted}

\paragraph{Current output:}

\begin{minted}{text}
NOT IMPLEMENTED YET
\end{minted}

\paragraph{Desired output:}

\begin{minted}{js}
y => y
\end{minted}

\paragraph{}

In all example programs we considered so far the argument to a function call was an immediate function definition, but in general arguments may be result of function calls themselves. We fix this by calling \mintinline{ts}{run()} recursively on the argument (we may also remove the check that the argument is an immediate function definition):

\begin{minted}[highlightlines = {3-4, 6}]{ts}
// run()
case "CallExpression":
  if (expression.callee.type !== "ArrowFunctionExpression")
    throw new Error("NOT IMPLEMENTED YET");
  // ...
  const argument = run(expression.arguments[0]);
  // ...
\end{minted}

\subsection{A Function That Is Not Immediate}
\label{A Function That Is Not Immediate}

\paragraph{Example program:}

\begin{minted}{js}
((z => z)(x => x))(y => y)
\end{minted}

\paragraph{Current output:}

\begin{minted}{text}
NOT IMPLEMENTED YET
\end{minted}

\paragraph{Desired output:}

\begin{minted}{js}
y => y
\end{minted}

\paragraph{}

This is the dual of §~\ref{An Argument That Is Not Immediate} for the called function, and the solution is the same (note the removal of another check):

\begin{minted}[highlightlines = {6}]{ts}
// run()
case "CallExpression":
  const {
    params: [{ name: parameter }],
    body
  } = run(expression.callee);
  // ...
\end{minted}

\subsection{Continuing to Run After a Function Call}
\label{Continuing to Run After a Function Call}

\paragraph{Example program:}

\begin{minted}{js}
(x => (z => z)(x))(y => y)
\end{minted}

\paragraph{Current output:}

\begin{minted}{text}
NOT IMPLEMENTED YET
\end{minted}

\paragraph{Desired output:}

\begin{minted}{js}
y => y
\end{minted}

\paragraph{}

This is similar to §~\ref{An Argument That Is Not Immediate} and §~\ref{A Function That Is Not Immediate}: the result of substitution may not be an immediate function, and more work is required to interpret it. We solve this with another recursive call to \mintinline{ts}{evaluate()} (note the removal of yet another check, which rendered the \mintinline{ts}{substitutedBody} variable superfluous):

\begin{minted}[highlightlines = {4}]{ts}
// run()
case "CallExpression":
  // ...
  return run(substitute(body));
  // ...
\end{minted}

\subsection{A Reference to an Undefined Variable}

\paragraph{Example program:}

\begin{minted}{js}
(x => y)(y => y)
\end{minted}

\paragraph{Current output:}

\begin{minted}{text}
NOT IMPLEMENTED YET
\end{minted}

\paragraph{Desired output:}

\begin{minted}{text}
Reference to undefined variable: y
\end{minted}

\paragraph{}

The only case in which \mintinline{ts}{run()} may encounter a variable reference directly is if the referenced variable is undefined, otherwise \mintinline{ts}{substitute()} would have already substituted it (see §~\ref{A Call Involving Immediate Functions}–§~\ref{Continuing to Run After a Function Call}). In this case, we throw an exception:

\begin{minted}[highlightlines = {3}]{ts}
// run()
case "Identifier":
  throw new Error(`Reference to undefined variable: ${expression.name}`);
\end{minted}

% TODO: A _frozen_ reference to an undefined variable is fine.

\subsection{The Entire Runner}

The implementation of the \mintinline{ts}{run()} function is complete:

\begin{minted}{ts}
function run(expression: Expression): Value {
  switch (expression.type) {
    case "ArrowFunctionExpression":
      return expression;
    case "CallExpression":
      const {
        params: [{ name: parameter }],
        body
      } = run(expression.callee);
      const argument = run(expression.arguments[0]);
      return run(substitute(body));
      function substitute(expression: Expression): Expression {
        switch (expression.type) {
          case "ArrowFunctionExpression":
            if (expression.params[0].name === parameter) return expression;
            return {
              ...expression,
              body: substitute(expression.body)
            };
          case "CallExpression":
            return {
              ...expression,
              callee: substitute(expression.callee),
              arguments: [substitute(expression.arguments[0])]
            };
          case "Identifier":
            if (expression.name !== parameter) return expression;
            return argument;
        }
      }
    case "Identifier":
      throw new Error(`Reference to undefined variable: ${expression.name}`);
  }
}
\end{minted}

% TODO: big-step

\subsection{Loader}
\label{Step 0: Loader}

% TODO: (This is a process called \emph{parsing}, and the data structures are called the \emph{Abstract Syntax Tree}~(AST) of the program~\cite[§~4]{dragon-book}.)

\subsection{Unloader}
\label{Step 0: Unloader}

% TODO

% TODO: § Inference rules for interpreter.

\appendix

\backmatter

\bibliographystyle{plain}
\bibliography{\jobname}

\chapter{Biographical Statement}

% TODO

\end{document}
